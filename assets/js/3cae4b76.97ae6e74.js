"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7950],{2250:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"documentation/core-concepts/workflow","title":"Workflow","description":"A Workflow is a way to chain Actions. The syntax is similar to how async/await syntax works.","source":"@site/docs/documentation/core-concepts/workflow.md","sourceDirName":"documentation/core-concepts","slug":"/documentation/core-concepts/workflow","permalink":"/documentation/core-concepts/workflow","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Workflow","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Action lifecycle","permalink":"/documentation/core-concepts/action-in-depth"},"next":{"title":"Resource","permalink":"/documentation/core-concepts/resource"}}');var o=t(4848),s=t(8453);const r={title:"Workflow",sidebar_position:2},a="Workflow documentation",c={},l=[{value:"Write a Workflow",id:"write-a-workflow",level:2},{value:"The do method",id:"the-do-method",level:3},{value:"Purpose",id:"purpose",level:4},{value:"Point of attention : deterministic execution and async/await",id:"point-of-attention--deterministic-execution-and-asyncawait",level:4},{value:"Action Step definition",id:"action-step-definition",level:3},{value:"On the fly promise definition",id:"on-the-fly-promise-definition",level:3},{value:"Dynamic definition",id:"dynamic-definition",level:3},{value:"Under the hood",id:"under-the-hood",level:3},{value:"repeat and transform",id:"repeat-and-transform",level:2},{value:"Action level",id:"action-level",level:3},{value:"Workflow level",id:"workflow-level",level:3},{value:"Transformation",id:"transformation",level:3},{value:"Examples",id:"examples",level:4},{value:"Simple example",id:"simple-example",level:5},{value:"Inheritance example",id:"inheritance-example",level:5}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"workflow-documentation",children:"Workflow documentation"})}),"\n",(0,o.jsxs)(n.p,{children:["A Workflow is a way to chain Actions. The syntax is similar to how async/await syntax works.\nA Workflow is also a specific type of ",(0,o.jsx)(n.code,{children:"Action"}),", so you can chain Workflows in other Workflows."]}),"\n",(0,o.jsx)("img",{src:"/img/workflow_orbits.png",alt:"Workflow Orbits"}),"\n",(0,o.jsx)(n.h2,{id:"write-a-workflow",children:"Write a Workflow"}),"\n",(0,o.jsxs)(n.p,{children:["A Workflow, same as an ",(0,o.jsx)(n.code,{children:"Action"}),", has an ",(0,o.jsx)(n.code,{children:"init()"})," method.\nA Workflow also has a ",(0,o.jsx)(n.code,{children:"define()"})," method where you can write your flow of Actions."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'export class MyWorkflow extends Workflow{\n\n    define(){\n        try{\n            await this.do("my-action", new MyAction().setArgument({\n                x: 1\n            }))\n        }\n        catch(err){\n            await this.do("on-error-action", new OnErrorAction().setArgument({\n                x: 1\n            }))\n        }\n        finally{\n            //....\n        }\n        return {\n            x: 2\n        }\n    }\n\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"the-do-method",children:"The do method"}),"\n",(0,o.jsx)(n.h4,{id:"purpose",children:"Purpose"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"do()"})," method is used to declare an action to be executed within the workflow. It mimics the behavior of await in native JavaScript/TypeScript syntax to provide readable, sequential flow control."]}),"\n",(0,o.jsxs)(n.p,{children:["However, ",(0,o.jsx)(n.code,{children:"do()"})," is more complex than a normal asynchronous call. Behind the scenes, the orbits framework implements deterministic execution with built-in replayability. This means:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"define()"})," can be executed multiple times during the lifecycle of a workflow."]}),"\n",(0,o.jsxs)(n.li,{children:["Each call to ",(0,o.jsx)(n.code,{children:"do()"})," is idempotent: the action is only executed once."]}),"\n",(0,o.jsxs)(n.li,{children:["On re-execution, previously completed ",(0,o.jsx)(n.code,{children:"do()"})," calls return the stored result instead of re-running the action."]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"point-of-attention--deterministic-execution-and-asyncawait",children:"Point of attention : deterministic execution and async/await"}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'export class BadWorkflow extends Workflow {\n  define() {\n    const search = await axios.get("https://google.com?search=test"); // \u274c Not deterministic\n\n    if (search.length) {\n      await this.do("step-a", new StepA());\n    } else {\n      await this.do("step-b", new StepB());\n    }\n\n    return { status: "done" };\n  }\n}\n'})})}),"\n",(0,o.jsx)(n.admonition,{type:"success",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'export class CorrectWorkflow extends Workflow {\n  define() {\n    const search = await this.do("search", ()=>{\n        axios.get("https://google.com?search=test"\n    });\n\n    if (search.length) {\n      await this.do("step-a", new StepA());\n    } else {\n      await this.do("step-b", new StepB());\n    }\n\n    return { status: "done" };\n  }\n}\n'})})}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'export class BadWorkflow extends Workflow {\n  define() {\n    const now = Date.now(); // \u274c Not deterministic\n\n    if (now % 2 === 0) {\n      await this.do("step-a", new StepA());\n    } else {\n      await this.do("step-b", new StepB());\n    }\n\n    return { now };\n  }\n}\n'})})}),"\n",(0,o.jsx)(n.admonition,{type:"success",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'export class CorrectWorkflow extends Workflow {\n\n    IBag: {\n        now : number\n  \n    }\n\n  async init(){\n    await super.init();\n    if(!this.bag.now){\n        this.bag.now = Date.now()\n    }\n  }\n\n  define() {\n\n    if (this.bag.now % 2 === 0) {\n      await this.do("step-a", new StepA());\n    } else {\n      await this.do("step-b", new StepB());\n    }\n\n    return { now: this.bag.now };\n  }\n}\n'})})}),"\n",(0,o.jsx)(n.h3,{id:"action-step-definition",children:"Action Step definition"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"do()"})," method accepts an ",(0,o.jsx)(n.code,{children:"Action"})," instance as its argument:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'  await this.do("step-a", new MyAction().setArgument({"some": "argument"}));\n'})}),"\n",(0,o.jsx)(n.p,{children:"The action will be persisted in the database and executed in an isolated context."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The result of the ",(0,o.jsx)(n.code,{children:"await"})," will be the result of the action."]}),"\n",(0,o.jsxs)(n.li,{children:["If the final action's state is ",(0,o.jsx)(n.code,{children:"ActionState.ERROR"}),", the do() method will throw the error \u2014 allowing standard error handling using try/catch."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"on-the-fly-promise-definition",children:"On the fly promise definition"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"do()"})," method also accepts a callback that returns a Promise."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'  await this.do("step-a", ()=>{\n    return Promise.resolve()\n  });\n\n  await this.do("step-b", myAsyncFunction.bind("some", "argument"))\n'})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The promise will be executed once and only once."}),"\n",(0,o.jsx)(n.li,{children:"The result of the await will be the resolved value of the promise."}),"\n",(0,o.jsxs)(n.li,{children:["If an error occurs, it will be thrown by ",(0,o.jsx)(n.code,{children:"do()"})," and can be handled via ",(0,o.jsx)(n.code,{children:"try/catch"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"dynamic-definition",children:"Dynamic definition"}),"\n",(0,o.jsxs)(n.p,{children:["Dynamic definitions are useful when you need to pass non-serializable parameters, such as functions.\nSince actions are stored in the database, only ",(0,o.jsx)(n.code,{children:"JSONObject"}),"-compatible properties can be persisted.\nTo pass methods or closures through the chain of actions, use the dynamicAction option:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'const action = new MyAction();\n//override a method of your action\naction.getCredentials = ()=>{\n  return this.specificConfig.getCredentials()\n}\nawait this.do("step-a", {dynamicAction: action});\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The action will be persisted in the database and executed in an isolated context.\nWhen executed, ",(0,o.jsx)(n.code,{children:"getCredentials"})," will be overriden with this definition specific to the workflow context."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The result of the ",(0,o.jsx)(n.code,{children:"await"})," will be the result of the action."]}),"\n",(0,o.jsxs)(n.li,{children:["If the final action's state is ",(0,o.jsx)(n.code,{children:"ActionState.ERROR"}),", the do() method will throw the error \u2014 allowing standard error handling using try/catch."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"under-the-hood",children:"Under the hood"}),"\n",(0,o.jsx)(n.p,{children:"Under the hood the do method return a standard javascript promise.\nHowever this promises not always resolve."}),"\n",(0,o.jsx)(n.p,{children:"Let's say we have a workflow with two steps :"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'export class MyWorkflow extends Workflow{\n\n  define(){\n    const result = await this.do("step-a", new LongTermAction());\n    await this.do("step-b", new MyAction().setArgument(result));\n  }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Here is the flow of calls that happens."}),"\n",(0,o.jsx)(n.mermaid,{value:'\nstateDiagram-v2\n  direction LR\n  state "Workflow is sleeping" as WSleep{\n    [*]\n  }\n\n  WSleep --\x3e WMain1\n  state "Workflow is executing main" as WMain1 {\n      define --\x3e stepA\n      stepA --\x3e actionA\n      actionA --\x3e actionAInProgress\n      actionAInProgress --\x3e inProgress\n      inProgress --\x3e inProgress2\n      actionAInProgress\n      define: define() is called\n      stepA: do("step-a",...) is called\n      actionA: actionA is started\n      actionAInProgress: actionA is in progress\n      inProgress: do("step-a",...) never returns\n      inProgress2: define() never returns\n  }\n\n  WMain1 --\x3e WProgress\n  state "Workflow is in progress" as WProgress{\n      [*] --\x3e IsPositive\n      IsPositive: check actionA state\n      state if_state <<choice>>\n      IsPositive --\x3e if_state\n      if_state --\x3e IsPositive: if actionA is in progress\n      if_state --\x3e actionA3: if actionA succeeded\n      actionA3: workflow entering main\n\n  } \n\n  WProgress --\x3e WMain2\n  state "Workflow is executing main again" as WMain2{\n    define2--\x3estepA2\n    stepA2 --\x3e stepA3\n    stepA3 --\x3e stepA4\n    stepA4 --\x3e stepA5\n    stepA5 --\x3e defineEnd\n    define2: define() is called\n    stepA2: do("step-a",...) is called\n    stepA3: do("step-a",...) returns the result of the "LongTermAction"\n    stepA4: do("step-b",...) is called\n    stepA5: do("step-b",...) returns\n    defineEnd: define returns\n  }\n\n  WMain2 --\x3e WSuccess\n  state "Workflow is a success" as WSuccess{\n    [*]\n  }'}),"\n",(0,o.jsx)(n.h2,{id:"repeat-and-transform",children:"repeat and transform"}),"\n",(0,o.jsx)(n.h3,{id:"action-level",children:"Action level"}),"\n",(0,o.jsxs)(n.p,{children:["At the action level, you can configure the repetion using the ",(0,o.jsx)(n.code,{children:"setRepeat()"})," method.\nExample :"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'export class MyWorkflow extends Workflow{\n\n    define(){\n        try{\n            await this.do("my-action", new MyAction().setArgument({\n                x: 1\n            }).setRepeat({\n                [ActionState.ERROR]: 2 //repeat twice, so will be executed max. 3 times\n            }))\n        }\n        catch(err){\n            await this.do("on-error-action", new OnErrorAction().setArgument({\n                x: 1\n            }))\n        }\n        finally{\n            //....\n        }\n        return {\n            x: 2\n        }\n    }\n\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"workflow-level",children:"Workflow level"}),"\n",(0,o.jsxs)(n.p,{children:["At the workflow level, you can configure the repetion using the ",(0,o.jsx)(n.code,{children:"doRepeat()"})," method.\nExample :"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'export class WorkflowWithRepeat extends Workflow{\n\n    async define(){\n        await this.repeatDo("repeatSucces", ()=>{\n            //...do something...\n            return Promise.resolve()\n        },{\n            [ActionState.SUCCESS]: 2,\n            elapsedTime: 10 \n        })\n\n        try{\n            await this.repeatDo("repeatOnFailure", ()=>{\n                //...do something...\n                return Promise.reject()\n            }, {\n                [ActionState.ERROR]: 2,\n                elapsedTime: 10\n            })\n        }\n        catch(err){\n\n        }\n        return i;\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"transformation",children:"Transformation"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"transform()"})," method is a powerful hook that intercepts every Action before it is executed by the Workflow."]}),"\n",(0,o.jsx)(n.p,{children:"It acts as a proxy layer over all Actions that pass through the Workflow engine. You can use it to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Modify the arguments of any Action"}),"\n",(0,o.jsx)(n.li,{children:"Replace one Action with another"}),"\n",(0,o.jsx)(n.li,{children:"Apply conditional logic"}),"\n",(0,o.jsxs)(n.li,{children:["Dynamically set ",(0,o.jsx)(n.code,{children:".setRepeat()"}),", ",(0,o.jsx)(n.code,{children:".setTimeout()"}),", ",(0,o.jsx)(n.code,{children:".setBag()"}),", etc."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["This is especially useful when you want to customize or override Action behavior without changing the Workflow's ",(0,o.jsx)(n.code,{children:"define()"})," logic."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h4,{id:"examples",children:"Examples"}),"\n",(0,o.jsx)(n.h5,{id:"simple-example",children:"Simple example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'export class MyWorkflow extends Workflow {\n\n  // The transform method allows you to intercept and modify actions dynamically.\n  transform(ref: string, action: Action): Action {\n    if (ref === "my-action") {\n      // Override the arguments for the step "my-action"\n      return MyAction().setArgument({\n        x: 2,\n      });\n    }\n\n    // Returning `undefined` means the original action instance will be used as-is\n    return;\n  }\n\n  async define() {\n    try {\n      await this.do(\n        "my-action",\n        MyAction().setArgument({\n          x: 1,\n        }).setRepeat({\n          [ActionState.ERROR]: 2, // Retry up to 2 times on error (executed max 3 times)\n        })\n      );\n    } catch (err) {\n      await this.do(\n        "on-error-action",\n        OnErrorAction().setArgument({\n          x: 1,\n        })\n      );\n    } finally {\n      // You can perform cleanup or additional steps here\n    }\n\n    return {\n      x: 2,\n    };\n  }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Key Notes"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"ref"})," argument passed to ",(0,o.jsx)(n.code,{children:"transform()"}),' matches the name you use in this.do("my-action", ...).']}),"\n",(0,o.jsx)(n.li,{children:"You must return a valid Action instance if you want to replace or modify it."}),"\n",(0,o.jsxs)(n.li,{children:["If ",(0,o.jsx)(n.code,{children:"transform()"})," returns ",(0,o.jsx)(n.code,{children:"undefined"}),", the original ",(0,o.jsx)(n.code,{children:"Action"})," provided in ",(0,o.jsx)(n.code,{children:"define()"})," will be used."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Use this to:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Inject environment-specific parameters (e.g. test vs. prod)"}),"\n",(0,o.jsx)(n.li,{children:"Dynamically change retry logic or timeouts"}),"\n",(0,o.jsx)(n.li,{children:"Centralize logic for versioning or conditional behavior"}),"\n"]}),"\n",(0,o.jsx)(n.h5,{id:"inheritance-example",children:"Inheritance example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'export class CustomWorkflow extends BaseWorkflow {\n  \n  transform(ref: string, action: Action): Action {\n    if (ref === "notify") {\n      // Override the default email step with a custom SMS notification\n      return new SendSmsAction().setArgument({\n        message: "This replaces the email notification"\n      });\n    }\n    return;\n  }\n  \n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"This pattern allows you to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Reuse shared workflow logic"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Swap or extend individual steps based on context"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Build a hierarchy of workflows with consistent interfaces but customizable behavior"}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);