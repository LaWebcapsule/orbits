"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3306],{4884:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"documentation/core-concepts/resource","title":"Resource","description":"A Resource is a specialized type of Workflow designed to orchestrate the lifecycle of real-world entities, such as cloud accounts, services, or data systems. Resources provide a declarative and persistent way to manage these entities through versioning, reconciliation, shared state, and scheduled verification.","source":"@site/docs/documentation/core-concepts/resource.md","sourceDirName":"documentation/core-concepts","slug":"/documentation/core-concepts/resource","permalink":"/documentation/core-concepts/resource","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Resource","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Workflow","permalink":"/documentation/core-concepts/workflow"},"next":{"title":"Environment variables and runtime","permalink":"/documentation/core-concepts/runtime"}}');var c=t(4848),o=t(8453);const r={title:"Resource",sidebar_position:3},i="Resource documentation",a={},d=[{value:"Write a Resource",id:"write-a-resource",level:2},{value:"the <code>identity</code> of a resource",id:"the-identity-of-a-resource",level:3},{value:"Persistent storage for resources",id:"persistent-storage-for-resources",level:4},{value:"Resource output",id:"resource-output",level:4},{value:"Resource lifecycle commands",id:"resource-lifecycle-commands",level:3},{value:"Install hook",id:"install-hook",level:4},{value:"Update",id:"update",level:4},{value:"Uninstall",id:"uninstall",level:4},{value:"Cycle",id:"cycle",level:4},{value:"Using resources in a workflow",id:"using-resources-in-a-workflow",level:4},{value:"Custom Hooks",id:"custom-hooks",level:4},{value:"Convergent Execution (Coalescing)",id:"convergent-execution-coalescing",level:3},{value:"Divergent Execution (lock)",id:"divergent-execution-lock",level:3},{value:"Digest method",id:"digest-method",level:3}];function l(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"resource-documentation",children:"Resource documentation"})}),"\n",(0,c.jsx)(n.p,{children:"A Resource is a specialized type of Workflow designed to orchestrate the lifecycle of real-world entities, such as cloud accounts, services, or data systems. Resources provide a declarative and persistent way to manage these entities through versioning, reconciliation, shared state, and scheduled verification."}),"\n",(0,c.jsx)(n.p,{children:"Resources offer:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Retroactive control loops"}),"\n",(0,c.jsx)(n.li,{children:"Shared workflow state via identity"}),"\n",(0,c.jsx)(n.li,{children:"Output reuse across executions"}),"\n",(0,c.jsx)(n.li,{children:"Hookable lifecycle stages: install, update, uninstall, and cycle"}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"write-a-resource",children:"Write a Resource"}),"\n",(0,c.jsxs)(n.p,{children:["A Resource is a ",(0,c.jsx)(n.code,{children:"Workflow"})," with some specials behaviours."]}),"\n",(0,c.jsxs)(n.h3,{id:"the-identity-of-a-resource",children:["the ",(0,c.jsx)(n.code,{children:"identity"})," of a resource"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"export class MyResource extends Resource{\n\n    IArgument: {\n      accountId: string\n    }\n\n    identity(){\n      return this.argument.accountId;\n    }\n\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"The identity() method defines a unique key for the resource. All resource instances with the same constructor and identity value will share the same database document, lifecycle state, and output."}),"\n",(0,c.jsx)(n.p,{children:"This enables deduplication and stateful coordination between concurrent invocations."}),"\n",(0,c.jsx)(n.h4,{id:"persistent-storage-for-resources",children:"Persistent storage for resources"}),"\n",(0,c.jsx)(n.p,{children:"Each resource is backed by a shared database document, accessible via the resourceDbDoc property.\nSome properties of the document are internal to the framework and should not be modified unless you know what you are doing."}),"\n",(0,c.jsx)(n.h4,{id:"resource-output",children:"Resource output"}),"\n",(0,c.jsxs)(n.p,{children:["Each resource can define an output with the ",(0,c.jsx)(n.code,{children:"setOutput"})," method.\nOutputs are stored persistently and are available to other workflows or resource cycles."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"export class MyResource extends Resource{\n\n    IArgument: {\n      accountId: string\n    }\n\n    identity(){\n      return this.argument.accountId;\n    }\n\n    setOutput(){\n      return {\n        x : 1\n      }\n    }\n\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"Outputs can then be consume by other workflows or resources"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'export class MySecondResource extends Resource{\n\n    IArgument: {\n      accountId: string\n    }\n\n    identity(){\n      return this.argument.accountId;\n    }\n\n    setOutput(){\n      return {\n        x : 1\n      }\n    }\n\n    defineUpdate(){\n      const output = await this.do("get-output", new MyResource().setArgument(\n          {\n            accountId : this.argument.accountId\n        }).getResourceOutput;\n      )\n      await this.do("deploy", ()=>{\n        return new Service(output).create();\n      })\n    }\n\n}\n'})}),"\n",(0,c.jsx)(n.h3,{id:"resource-lifecycle-commands",children:"Resource lifecycle commands"}),"\n",(0,c.jsx)(n.p,{children:"Resources define lifecycle hooks. These correspond to specific setCommand() values and are executed based on state or schedule."}),"\n",(0,c.jsx)(n.h4,{id:"install-hook",children:"Install hook"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'export class MyResource extends Resource{\n\n    IArgument: {\n      accountId: string\n    }\n\n    identity(){\n      return this.argument.accountId;\n    }\n\n    version = "1.0.0"\n\n    async defineInstall(){\n      const myAccount = new Account();\n      await this.do("bootstrap", myAccount)\n    }\n\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"defineInstall"})," run :"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"when the resource has never been installed before"}),"\n",(0,c.jsx)(n.li,{children:"when the version field changes"}),"\n",(0,c.jsx)(n.li,{children:'when explicitly triggered with .setCommand("install")'}),"\n"]}),"\n",(0,c.jsx)(n.h4,{id:"update",children:"Update"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'export class MyResource extends Resource{\n\n    IArgument: {\n      accountId: string\n    }\n\n    identity(){\n      return this.argument.accountId;\n    }\n\n    version = "1.0.0"\n\n    async defineInstall(){\n      const myAccount = new Account();\n      await this.do("bootstrap", myAccount)\n    }\n\n    async defineUpdate(){\n      const service = new Service().setArgument({\n        accountId: this.argument.accountId\n      });\n      await this.do("launchService", service)\n    }\n\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"defineUpdate"})," run :"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"everytime a default execution runs."}),"\n",(0,c.jsxs)(n.li,{children:["if you force the execution of the ",(0,c.jsx)(n.code,{children:"update"})," step using ",(0,c.jsx)(n.code,{children:"setCommand('update')"})]}),"\n"]}),"\n",(0,c.jsx)(n.h4,{id:"uninstall",children:"Uninstall"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'export class MyResource extends Resource{\n\n    IArgument: {\n      accountId: string\n    }\n\n    identity(){\n      return this.argument.accountId;\n    }\n\n    version = "1.0.0"\n\n    async defineInstall(){\n      const myAccount = new Account();\n      await this.do("bootstrap", myAccount)\n    }\n\n    async defineUpdate(){\n      const service = new Service().setArgument({\n        accountId: this.argument.accountId\n      });\n      await this.do("launchService", ()=>{\n        return service.create()\n      })\n    }\n\n    async defineUninstall(){\n      const service = new Service().setArgument({\n        accountId: this.argument.accountId\n      });\n      await this.do("launchService", ()=>{\n        return service.delete()\n      })\n    }\n\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"defineUninstall()"})," runs only if explicitly triggered with ",(0,c.jsx)(n.code,{children:'.setCommand("uninstall")'})]}),"\n",(0,c.jsx)(n.h4,{id:"cycle",children:"Cycle"}),"\n",(0,c.jsxs)(n.p,{children:["Resources support a ",(0,c.jsx)(n.code,{children:"defineCycle()"})," method, triggered periodically to verify or reconcile the external-world state."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'export class MyResource extends Resource{\n\n    IArgument: {\n      accountId: string\n    }\n\n    identity(){\n      return this.argument.accountId;\n    }\n\n    version = "1.0.0"\n\n    async defineInstall(){\n      const myAccount = new Account();\n      await this.do("bootstrap", myAccount)\n    }\n\n    async defineUpdate(){\n      const service = new Service().setArgument({\n        accountId: this.argument.accountId\n      });\n      await this.do("launchService", ()=>{\n        return service.create()\n      })\n    }\n\n    async defineUninstall(){\n      const service = new Service().setArgument({\n        accountId: this.argument.accountId\n      });\n      await this.do("launchService", ()=>{\n        return service.delete()\n      })\n    }\n\n    defaultResourceSettings = {\n      cycle : {\n        frequency : 10*60*1000 //the cycle hook will run every ten minutes\n      }\n    }\n\n    async defineCycle(){\n      //by default do nothing\n    }\n\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"cycle"})," hook is called :"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["at the frequency stored in the ",(0,c.jsx)(n.code,{children:"resourceDbDoc"}),", path ",(0,c.jsx)(n.code,{children:"cycle.frequency"}),". You can set a first value for this frequency using ",(0,c.jsx)(n.code,{children:"defaultResourceSettings.cycle.frequency"}),"."]}),"\n",(0,c.jsxs)(n.li,{children:["if you force the execution of the ",(0,c.jsx)(n.code,{children:"cycle"})," step using ",(0,c.jsx)(n.code,{children:"setCommand('cycle')"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["By default, the ",(0,c.jsx)(n.code,{children:"cycle"})," hook do nothing. A simple strategy can be, to ensure your resources are up-to-date, to launch a complete digestion hook."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'export class MyResource extends Resource{\n\n    IArgument: {\n      accountId: string\n    }\n\n    identity(){\n      return this.argument.accountId;\n    }\n\n    version = "1.0.0"\n\n    async defineInstall(){\n      const myAccount = new Account();\n      await this.do("bootstrap", myAccount)\n    }\n\n    async defineUpdate(){\n      const service = new Service().setArgument({\n        accountId: this.argument.accountId\n      });\n      await this.do("launchService", ()=>{\n        return service.create()\n      })\n    }\n\n    async defineUninstall(){\n      const service = new Service().setArgument({\n        accountId: this.argument.accountId\n      });\n      await this.do("launchService", ()=>{\n        return service.delete()\n      })\n    }\n\n    defaultResourceSettings = {\n      cycle : {\n        frequency : 10*60*1000 //the cycle hook will run every ten minutes\n      }\n    }\n\n    async defineCycle(){\n      await this.do("digest", this.resource);//launch a digest cycle\n    }\n\n}\n'})}),"\n",(0,c.jsx)(n.h4,{id:"using-resources-in-a-workflow",children:"Using resources in a workflow"}),"\n",(0,c.jsx)(n.p,{children:"You can execute a Resource like any other Workflow. Its default command is derived from current state (e.g. install or update):"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'export class MyWorkflow extends Workflow{\n\n    define(){\n      await this.do("myResource", new MyResource().setArgument({ accountId }));\n    }\n\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"Or force a specific command:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"export class MyWorkflow extends Workflow{\n\n    define(){\n      this.do(\"resourceUpToDate\", new MyResource().setArgument({\n        accountId : this.argument.accountId\n      })).setCommand('update')\n    }\n}\n"})}),"\n",(0,c.jsx)(n.h4,{id:"custom-hooks",children:"Custom Hooks"}),"\n",(0,c.jsxs)(n.p,{children:["In addition to the standard lifecycle hooks (install, update, uninstall, cycle), a ",(0,c.jsx)(n.code,{children:"Resource"})," can expose custom hooks. These are useful when you want to support additional behaviors that do not fit into the predefined lifecycle."]}),"\n",(0,c.jsxs)(n.p,{children:["To define a custom hook, you simply create a ",(0,c.jsx)(n.code,{children:"defineX()"})," method, where ",(0,c.jsx)(n.code,{children:"X"})," is the name of your custom command (starting with an uppercase letter):"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'export class MyResource extends Resource {\n  IArgument: {\n    accountId: string;\n  };\n\n  identity() {\n    return this.argument.accountId;\n  }\n\n  async defineSyncPermissions() {\n    await this.do("syncIAM", new SyncIAMWorkflow().setArgument({\n      accountId: this.argument.accountId\n    }));\n  }\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["To invoke this hook, use ",(0,c.jsx)(n.code,{children:'.setCommand("syncPermissions")'})," from any workflow:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'await this.do("res", new MyResource()\n  .setArgument({ accountId })\n  .setCommand("syncPermissions"));\n'})}),"\n",(0,c.jsx)(n.p,{children:"Custom hooks allow resources to be extended with additional behaviors while still benefiting from identity-based deduplication and persistent state management."}),"\n",(0,c.jsx)(n.admonition,{type:"info",children:(0,c.jsxs)(n.p,{children:["Custom hook names must match the format ",(0,c.jsx)(n.code,{children:"defineMyCommand"}),', and are called by passing "myCommand" to setCommand() (case-sensitive).']})}),"\n",(0,c.jsx)(n.h3,{id:"convergent-execution-coalescing",children:"Convergent Execution (Coalescing)"}),"\n",(0,c.jsxs)(n.p,{children:["When multiple identical resource instances (same constructor and identity) are triggered concurrently ",(0,c.jsx)(n.strong,{children:"with the same command"}),", the system ensures that only one execution runs. The other invocations will wait and reuse the result of the running instance."]}),"\n",(0,c.jsx)(n.p,{children:"This is known as coalescing, and it ensures consistency, reduces overhead, and prevents race conditions.\nExample :"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'//...some context\n    await this.do("my-resource", new Resource().setCommand("update"))\n//...some other context elsewhere, called in the same time\n    await this.do("my-resource", new Resource().setCommand("update"))\n'})}),"\n",(0,c.jsxs)(n.p,{children:["The two workflows wants to run the ",(0,c.jsx)(n.code,{children:"update"})," resource command.\nOnly one ",(0,c.jsx)(n.code,{children:"update"})," resource command will be launched and the two workflows steps will have the same result."]}),"\n",(0,c.jsx)(n.h3,{id:"divergent-execution-lock",children:"Divergent Execution (lock)"}),"\n",(0,c.jsxs)(n.p,{children:["When multiple identical resource instances are triggered concurrently with ",(0,c.jsx)(n.em,{children:"different commands"}),", only one will execute. The others will fail with a lock error to prevent command conflicts."]}),"\n",(0,c.jsx)(n.p,{children:"Example :"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'//...some context\n    await this.do("my-resource", new Resource().setCommand("update"))\n//...some other context elsewhere, called in the same time\n    await this.do("my-resource", new Resource().setCommand("install")) //will be in error, as command \'update\' is being executed.\n'})}),"\n",(0,c.jsxs)(n.p,{children:["The first workflows wants to run the ",(0,c.jsx)(n.code,{children:"update"})," resource command.\nThe second workflows wants to run the ",(0,c.jsx)(n.code,{children:"install"})," resource command.\nIn this case, the update command will proceed, and the install command will be rejected due to command incompatibility."]}),"\n",(0,c.jsxs)(n.p,{children:["The set of mutually exclusive commands is defined in the ",(0,c.jsx)(n.code,{children:"noConcurrencyCommandNames"})," property of the Resource class. When adding custom hooks, you should include them in this list if they require exclusivity."]}),"\n",(0,c.jsxs)(n.admonition,{type:"info",children:[(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.em,{children:"Best practices:"})," Avoid manually specifying commands unless necessary. Let the resource determine the correct hook automatically."]}),(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'//...some context\n    await this.do("my-resource", new Resource())\n//...safely coalesce\n    await this.do("my-resource", new Resource()) \n'})})]}),"\n",(0,c.jsx)(n.h3,{id:"digest-method",children:"Digest method"}),"\n",(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"digest()"})," method determines which commands (hooks) should be executed based on the current state of the resource. It is called during each lifecycle cycle and can be customized when implementing advanced behavior."]}),"\n",(0,c.jsx)(n.p,{children:"Default implementation:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"async digest(): Promise<ScopeOfChanges<string>[]>{\n        const changes = [];\n        if(this.resourceDbDoc.version !== this.version){\n            changes.push(new ScopeOfChanges('install'));\n        }\n        if(this.resourceDbDoc.version){\n            //meaning a deploy already occurs\n            changes.push(new ScopeOfChanges('update'));\n        }\n        return changes;\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(6540);const c={},o=s.createContext(c);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);