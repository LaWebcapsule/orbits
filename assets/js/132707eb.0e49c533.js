"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[916],{724:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var s=n(8139),i=n(4848),r=n(8453);const o={slug:"workflows-orchestrate-microservices",title:"Write Node.js workflows to orchestrate microservices.",authors:["loic","louis"],image:"/static/img/docusaurus.png",tags:["orchestration","microservices","saga-pattern","orbits","workflow"]},a="Write Node.js workflows to orchestrate microservices",c={authorsImageUrls:[void 0,void 0]},l=[{value:"Why explicitly orchestrate workflows?",id:"why-explicitly-orchestrate-workflows",level:2},{value:"The Saga Orchestration Pattern",id:"the-saga-orchestration-pattern",level:2},{value:"Use Case",id:"use-case",level:2},{value:"The Implementation",id:"the-implementation",level:2},{value:"Workflow Visualization",id:"workflow-visualization",level:2},{value:"Benefits Summary",id:"benefits-summary",level:2},{value:"Going further",id:"going-further",level:2},{value:"Using lambdas async invocations",id:"using-lambdas-async-invocations",level:3},{value:"Using resources to manage concurrency",id:"using-resources-to-manage-concurrency",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={a:"a",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Databases follow the principle of transactions \u2014 a set of changes that must either all succeed or all fail. But when an application interacts with multiple databases or connects to various APIs (as is the case for most applications today), the guarantees of ACID are lost. Workflows, state machines, and the saga pattern help achieve a similar level of reliability, often at the cost of more complex code. Here, we introduce a ",(0,i.jsx)(t.strong,{children:"Node.js"})," framework that makes it easy to write such workflows in TypeScript."]}),"\n",(0,i.jsxs)(t.p,{children:["To follow along, you can find the full source code in ",(0,i.jsx)(t.a,{href:"https://github.com/LaWebcapsule/orbits/tree/main/samples/orchestrate-lambda",children:"Orbit\u2019s GitHub repository"}),"."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Alt text",src:n(3121).A+"",width:"1000",height:"400"})}),"\n",(0,i.jsx)(t.h2,{id:"why-explicitly-orchestrate-workflows",children:"Why explicitly orchestrate workflows?"}),"\n",(0,i.jsxs)(t.p,{children:["Let's take a common use case in a business application: ",(0,i.jsx)(t.strong,{children:"managing a stock trading transaction"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Here are the typical steps:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Check the price of a stock"}),"\n",(0,i.jsx)(t.li,{children:"Generate a buy or sell recommendation"}),"\n",(0,i.jsx)(t.li,{children:"Execute the recommended action"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"On the surface, these are simple asynchronous calls that could be chained in a function:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"async function trade() {\n  const stockPrice = await checkPrice();\n  const recommendation = await generateRecommendation(stockPrice);\n  return recommendation === 'buy' ? await buyStock(stockPrice) : await sellStock(stockPrice);\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"But in reality, problems accumulate:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"What to do if a third-party service fails?"}),"\n",(0,i.jsx)(t.li,{children:"What if a network error occurs?"}),"\n",(0,i.jsx)(t.li,{children:"If the Node.js process is interrupted, the trade stops halfway, with no memory of the ongoing buy/sell operation."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"These issues, far from being theoretical, can have financial consequences. For example, a buy or sell action that is forgotten or left halfway through can lead to losses for the company."}),"\n",(0,i.jsx)(t.h2,{id:"the-saga-orchestration-pattern",children:"The Saga Orchestration Pattern"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"https://microservices.io/patterns/data/saga.html",children:(0,i.jsx)(t.strong,{children:"Saga Orchestration Pattern"})})," effectively addresses these challenges. By centralizing workflow management in an orchestrator, this pattern mimics the transaction principle of a database. It allows a series of atomic actions, executed sequentially and under control, to be linked together into a global transaction."]}),"\n",(0,i.jsx)(t.p,{children:"The orchestrator:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Explicitly manages state transitions between each step."}),"\n",(0,i.jsx)(t.li,{children:"Persists workflow state to ensure recovery after crashes."}),"\n",(0,i.jsx)(t.li,{children:"Can replay actions in case of transient failure."}),"\n",(0,i.jsx)(t.li,{children:"Provides detailed traceability through clear naming of each step."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Thus, the Saga Orchestration pattern not only guarantees resilience and consistency of operations but also facilitates maintenance, monitoring, and evolution of complex workflows in a distributed environment."}),"\n",(0,i.jsx)(t.h2,{id:"use-case",children:"Use Case"}),"\n",(0,i.jsxs)(t.p,{children:["In this blog post, we revisit the example of orchestrating a banking transaction. This canonical example was provided by ",(0,i.jsx)(t.a,{href:"https://docs.aws.amazon.com/step-functions/latest/dg/sample-lambda-orchestration.html",children:"AWS Step Functions"})," and ",(0,i.jsx)(t.a,{href:"https://temporal.io/blog/temporal-replaces-state-machines-for-distributed-applications",children:"Temporal"}),". Readers can refer to these articles to compare the syntax and ease of implementation offered by each tool."]}),"\n",(0,i.jsx)(t.h2,{id:"the-implementation",children:"The Implementation"}),"\n",(0,i.jsxs)(t.p,{children:["Orbits proposes writing workflows in a structured and declarative manner.\nYou can explore and experiment with the full source code of the example described in this blog post in ",(0,i.jsx)(t.a,{href:"https://github.com/LaWebcapsule/orbits/tree/main/samples/orchestrate-lambda",children:"Orbit\u2019s GitHub repository"}),".",(0,i.jsx)(t.br,{}),"\n","Here's the concrete example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",metastring:'title="src/orbits/workflows/trading.ts" wordWrap=true',children:'export class TradingWorkflow extends Workflow{\n\n declare IResult:StockTransaction\n\n async define(){\n  const checkPrice = await this.do("check-price", new CheckStockPriceAction());\n  const stockPrice = checkPrice.stockPrice;\n\n  const buyOrSell = await this.do("recommandation", \n    new GenerateBuySellRecommendationAction()\n    .setArgument(\n        {\n            price:stockPrice.stock_price\n        })\n    ); \n\n\n  if (buyOrSell.buyOrSellRecommendation === \'sell\') {\n    const sell = await this.do("sell", new SellStockeAction().setArgument({\n            price:stockPrice.stock_price\n    }));\n    return sell.stockData;\n  } else {\n    const buy = await this.do("buy", new BuyStockAction().setArgument({\n            price:stockPrice.stock_price\n    }));\n    return buy.stockData;\n  }\n };\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This central workflow orchestrates each step by calling autonomous ",(0,i.jsx)(t.strong,{children:"Actions"}),", while maintaining branching logic and intermediate states."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Explicit orchestration"}),": The Orbits engine manages calls, errors, retries, and state persistence"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Atomic actions"}),": Each business step is an independent and testable action"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Conditional branching"}),": The workflow flow can diverge based on data (buy or sell). It does not differ from standard TypeScript code."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Extensibility"}),": We can easily add steps, compensation logic, monitoring"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Resilience"}),": Handles crash recovery, workflow state, and observability"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Each step is defined as an ",(0,i.jsx)(t.strong,{children:"Orbits Action"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Here's the implementation of the buy action:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"export class BuyStockAction extends Action {\n    async main() {\n        const response = await fetch(API_ADDRESS + 'buyStock', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ stock_price: this.argument.price })\n        });\n        this.result.stockData = await response.json();\n        return ActionState.SUCCESS;\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"This action:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Takes a ",(0,i.jsx)(t.strong,{children:"typed input"})," (price)"]}),"\n",(0,i.jsx)(t.li,{children:"Calls a remote API in an encapsulated manner"}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Returns a state - ActionState.SUCCESS"}),", ready to be recorded and resumed"]}),"\n",(0,i.jsxs)(t.li,{children:["Handles ",(0,i.jsx)(t.strong,{children:"errors by default via a state - ActionState.ERROR"})]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["This structuring makes the action not only ",(0,i.jsx)(t.strong,{children:"easy to test in isolation"})," but also ",(0,i.jsx)(t.strong,{children:"reusable in different workflows"}),", while simplifying its instrumentation for monitoring or debugging."]}),"\n",(0,i.jsx)(t.h2,{id:"workflow-visualization",children:"Workflow Visualization"}),"\n",(0,i.jsx)(t.p,{children:"Here's a schematic representation of the orchestrated process:"}),"\n",(0,i.jsx)(t.mermaid,{value:'flowchart TD\n    Start["Start"] --\x3e CheckPrice["CheckStockPrice"]\n    CheckPrice --\x3e GenerateRec["GenerateRecommendation"]\n    GenerateRec --\x3e Decision{"Buy or Sell?"}\n    Decision --\x3e|Buy| BuyStock["BuyStock"]\n    Decision --\x3e|Sell| SellStock["SellStock"]\n    BuyStock --\x3e End["End"]\n    SellStock --\x3e End'}),"\n",(0,i.jsx)(t.h2,{id:"benefits-summary",children:"Benefits Summary"}),"\n",(0,i.jsx)(t.p,{children:"Adopting Orbits offers:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Standard TypeScript"})}),"\n",(0,i.jsx)(t.p,{children:"Orbits is a standard TypeScript framework. You write promises and asynchronous functions just like you would anywhere else."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Clear separation of responsibilities"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Workflow"})," = orchestration"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Action"})," = unit business logic"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Flexibility & Scalability"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"We can modify the flow without touching business components"}),"\n",(0,i.jsx)(t.li,{children:"Actions are reusable in multiple workflows"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Resilience and recovery"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Orbits manages state persistence"}),"\n",(0,i.jsx)(t.li,{children:"Automatic recovery from the last valid point"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Native observability"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Each action is traceable, named, monitorable"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"going-further",children:"Going further"}),"\n",(0,i.jsx)(t.h3,{id:"using-lambdas-async-invocations",children:"Using lambdas async invocations"}),"\n",(0,i.jsx)(t.p,{children:"For the sake of hypothesis, let\u2019s assume our Lambda function runs for an extended period of time (which is not the case here). In such scenarios, there\u2019s a high chance that the initial HTTP call triggering the Lambda might fail unexpectedly\u2014due to a network issue or timeout, for example."}),"\n",(0,i.jsx)(t.p,{children:"To prevent such failures from disrupting the overall workflow, you can configure retry policies."}),"\n",(0,i.jsxs)(t.p,{children:["Orbits also supports asynchronous APIs and allows you to track execution status over time. When dealing with long-running Lambda functions, an Orbits action can return with an ",(0,i.jsx)(t.code,{children:"ActionState.IN_PROGRESS"}),", and then delegate the follow-up logic to the ",(0,i.jsx)(t.code,{children:"watcher()"})," ",(0,i.jsx)(t.a,{href:"/documentation/core-concepts/action",children:"method"}),", which periodically checks the progress of the async process."]}),"\n",(0,i.jsx)(t.p,{children:"This approach requires a bit of additional setup, as you\u2019ll need to interact with the AWS Lambda API to track the specific invocation\u2019s result."}),"\n",(0,i.jsx)(t.p,{children:"We\u2019ll cover how Orbits makes it easy to manage long-running processes in a dedicated blog post soon."}),"\n",(0,i.jsx)(t.h3,{id:"using-resources-to-manage-concurrency",children:"Using resources to manage concurrency"}),"\n",(0,i.jsxs)(t.p,{children:["In our example, if we trigger the same order twice, it will be processed twice\u2014this isn\u2019t always the desired behavior.\nOrbits provides an opinionated way to handle concurrency through a concept called resources. ",(0,i.jsx)(t.a,{href:"/documentation/core-concepts/resource",children:"Resources"})," allow you to control and limit the execution of actions to prevent unintended duplication."]}),"\n",(0,i.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(t.p,{children:["With the simplicity of ",(0,i.jsx)(t.strong,{children:"Orbits in Node.js"}),", we can build systems that are reliable, readable, and maintainable, without changing your coding practices."]}),"\n",(0,i.jsxs)(t.p,{children:["For your critical processes \u2014 e-commerce, finance, logistics, etc. \u2014 ",(0,i.jsx)(t.strong,{children:"adopting such an approach will significantly reduce your bug rate and inconsistencies"}),"."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.em,{children:["Learn more about Orbits and its capabilities in our ",(0,i.jsx)(t.a,{href:"/documentation/quick-start",children:"documentation"}),"."]})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},3121:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/lightweight-temporal-a946451559f51e2a12a3c45c29d3eca5.png"},8139:e=>{e.exports=JSON.parse('{"permalink":"/blog/workflows-orchestrate-microservices","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-07-22-orchestate-microservices.md","source":"@site/blog/2025-07-22-orchestate-microservices.md","title":"Write Node.js workflows to orchestrate microservices.","description":"Databases follow the principle of transactions \u2014 a set of changes that must either all succeed or all fail. But when an application interacts with multiple databases or connects to various APIs (as is the case for most applications today), the guarantees of ACID are lost. Workflows, state machines, and the saga pattern help achieve a similar level of reliability, often at the cost of more complex code. Here, we introduce a Node.js framework that makes it easy to write such workflows in TypeScript.","date":"2025-07-22T00:00:00.000Z","tags":[{"inline":true,"label":"orchestration","permalink":"/blog/tags/orchestration"},{"inline":true,"label":"microservices","permalink":"/blog/tags/microservices"},{"inline":true,"label":"saga-pattern","permalink":"/blog/tags/saga-pattern"},{"inline":true,"label":"orbits","permalink":"/blog/tags/orbits"},{"inline":true,"label":"workflow","permalink":"/blog/tags/workflow"}],"readingTime":5.64,"hasTruncateMarker":true,"authors":[{"name":"Lo\xefc D\xe9champs","title":"CTO @ Webcapsule","url":"https://github.com/ldechamps","page":{"permalink":"/blog/authors/loic"},"socials":{"linkedin":"https://www.linkedin.com/in/loicdechamps/","github":"https://github.com/ldechamps"},"imageURL":"/img/authors/loic.png","key":"loic"},{"name":"Louis Dussarps","title":"CEO @ Webcapsule","url":"https://github.com/louisdussarps","page":{"permalink":"/blog/authors/louis"},"socials":{"linkedin":"https://www.linkedin.com/in/louisdussarps/","github":"https://github.com/louisdussarps"},"imageURL":"/img/authors/louis.png","key":"louis"}],"frontMatter":{"slug":"workflows-orchestrate-microservices","title":"Write Node.js workflows to orchestrate microservices.","authors":["loic","louis"],"image":"/static/img/docusaurus.png","tags":["orchestration","microservices","saga-pattern","orbits","workflow"]},"unlisted":false,"nextItem":{"title":"Automate deployments of cdk8s template","permalink":"/blog/programmable-cdk8s-deployment"}}')},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(6540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);