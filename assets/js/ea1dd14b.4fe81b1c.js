"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2201],{3526:e=>{e.exports=JSON.parse('{"permalink":"/blog/cross-account-cdk","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-06-25-cross-account-cdk.md","source":"@site/blog/2025-06-25-cross-account-cdk.md","title":"Solving cross-account resources for AWS CDK","description":"If you\'ve ever tried to build a multi-account AWS architecture using CDK or CloudFormation, you\'ve probably hit the same frustrating wall: cross-account resource references don\'t work without manual coordination and hardcoded values. What should be a simple task\u2014like reading a parameter from Account A in a Lambda function deployed to Account B\u2014becomes a tedious manual process. This behaviour is already documented and while AWS also documents workarounds, there\u2019s no indication that this is going to change anytime soon. However, these approaches don\'t scale when you have multiple services and resources spanning different accounts across your organization.","date":"2025-06-25T00:00:00.000Z","tags":[{"inline":true,"label":"aws-cdk","permalink":"/blog/tags/aws-cdk"},{"inline":true,"label":"orbits","permalink":"/blog/tags/orbits"}],"readingTime":6.81,"hasTruncateMarker":true,"authors":[{"name":"Louis Dussarps","title":"CEO @ Webcapsule","url":"https://github.com/louisdussarps","page":{"permalink":"/blog/authors/louis"},"socials":{"linkedin":"https://www.linkedin.com/in/louisdussarps/","github":"https://github.com/louisdussarps"},"imageURL":"/img/authors/louis.png","key":"louis"}],"frontMatter":{"slug":"cross-account-cdk","title":"Solving cross-account resources for AWS CDK","authors":["louis"],"tags":["aws-cdk","orbits"]},"unlisted":false,"prevItem":{"title":"Automate deployments of cdk8s template","permalink":"/blog/programmable-cdk8s-deployment"},"nextItem":{"title":"Infra is code","permalink":"/blog/manifesto"}}')},3728:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var a=t(3526),s=t(4848),r=t(8453);const o={slug:"cross-account-cdk",title:"Solving cross-account resources for AWS CDK",authors:["louis"],tags:["aws-cdk","orbits"]},i="Solving AWS Cross-Account Resource Access through CDK Orchestration",c={authorsImageUrls:[void 0]},l=[{value:"The Cross-Account Problem",id:"the-cross-account-problem",level:2},{value:"A Real-World Example",id:"a-real-world-example",level:2},{value:"The Traditional CDK Approach (Doesn&#39;t scale)",id:"the-traditional-cdk-approach-doesnt-scale",level:3},{value:"The Orchestration Solution with orbits",id:"the-orchestration-solution-with-orbits",level:3},{value:"Hands-On: Building the Example",id:"hands-on-building-the-example",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Project Setup",id:"project-setup",level:3},{value:"Project structure",id:"project-structure",level:3},{value:"The Resource Definitions",id:"the-resource-definitions",level:3},{value:"Lambda and Param CDK Stack",id:"lambda-and-param-cdk-stack",level:4},{value:"Lambda stack",id:"lambda-stack",level:5},{value:"Parameter stack",id:"parameter-stack",level:4},{value:"Encapsulate the stacks in a resource definition.",id:"encapsulate-the-stacks-in-a-resource-definition",level:4},{value:"Write a proxy resource to orchestrate both lambda and param deployment",id:"write-a-proxy-resource-to-orchestrate-both-lambda-and-param-deployment",level:4},{value:"Install step",id:"install-step",level:5},{value:"Update step",id:"update-step",level:5},{value:"Uninstall step",id:"uninstall-step",level:4},{value:"Deployment",id:"deployment",level:3},{value:"Verification",id:"verification",level:4},{value:"Cleanup",id:"cleanup",level:3},{value:"Why This Matters",id:"why-this-matters",level:2},{value:"Key Benefits",id:"key-benefits",level:3},{value:"Looking Forward",id:"looking-forward",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["If you've ever tried to build a multi-account AWS architecture using CDK or CloudFormation, you've probably hit the same frustrating wall: cross-account resource references don't work without manual coordination and hardcoded values. What should be a simple task\u2014like reading a parameter from Account A in a Lambda function deployed to Account B\u2014becomes a tedious manual process. This behaviour is already ",(0,s.jsx)(n.a,{href:"https://www.luminis.eu/blog/cross-account-aws-resource-access-with-aws-cdk/",children:"documented"})," and while AWS also documents ",(0,s.jsx)(n.a,{href:"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/walkthrough-crossstackref.html",children:"workarounds"}),", there\u2019s no indication that this is going to change anytime soon. However, these approaches don't scale when you have multiple services and resources spanning different accounts across your organization."]}),"\n",(0,s.jsx)(n.p,{children:"This post walks through a practical example that demonstrates both the problem and a solution using orbits, a tool designed to seamless orchestrate all of your IaC with code."}),"\n",(0,s.jsx)(n.h2,{id:"the-cross-account-problem",children:"The Cross-Account Problem"}),"\n",(0,s.jsx)(n.p,{children:"AWS CDK and CloudFormation have a limitation: stacks cannot directly reference resources from other AWS accounts. This creates friction for common architectural patterns like:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sharing Docker images between development and production accounts"}),"\n",(0,s.jsx)(n.li,{children:"Accessing centralized secrets from distributed applications"}),"\n",(0,s.jsx)(n.li,{children:"Setting up VPC peering connections"}),"\n",(0,s.jsx)(n.li,{children:"Managing cross-account S3 bucket permissions"}),"\n",(0,s.jsx)(n.li,{children:"Distributing Lambda layers across organizational boundaries"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Here's what this limitation looks like in practice:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const app = new cdk.App()\n\nconst paramA = new ParamStack(app, 'stack-A', {\n    env: { account: \"account-A\" }\n})\n\nconst lambdaB = new LambdaStack(app, 'stack-B', {\n    parameterArn: paramA.parameter.arn, // \u274c This fails at synthesis time\n    env: { account: \"account-B\" }\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"The traditional workaround involves manual steps: extracting ARNs, hardcoding values, coordinating resource policies, and deploying in specific sequences. This breaks the declarative nature of infrastructure-as-code and makes architectures brittle."}),"\n",(0,s.jsx)(n.h2,{id:"a-real-world-example",children:"A Real-World Example"}),"\n",(0,s.jsx)(n.p,{children:'Here\'s an "hello-world" scenario to illustrate the problem: deploying an AWS Systems Manager parameter in Account A and reading it from a Lambda function in Account B. While the "cross-account sharing" feature for AWS SSM parameter could be used, this simple use case illustrates the broader challenge perfectly.'}),"\n",(0,s.jsx)(n.h3,{id:"the-traditional-cdk-approach-doesnt-scale",children:"The Traditional CDK Approach (Doesn't scale)"}),"\n",(0,s.jsx)(n.p,{children:"With standard CDK, you'd need to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Deploy the parameter stack in Account A"}),"\n",(0,s.jsx)(n.li,{children:"Manually extract the parameter ARN"}),"\n",(0,s.jsx)(n.li,{children:"Hardcode the ARN into your Lambda stack for Account B"}),"\n",(0,s.jsx)(n.li,{children:"Manually configure cross-account IAM policies"}),"\n",(0,s.jsx)(n.li,{children:"Deploy the Lambda stack in Account B"}),"\n",(0,s.jsx)(n.li,{children:"Hope nothing changes, because updates require repeating this process"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"the-orchestration-solution-with-orbits",children:"The Orchestration Solution with orbits"}),"\n",(0,s.jsx)(n.p,{children:"With orbits, the same architecture becomes straightforward:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const paramOutput = await this.do("updateParam", new ParamResource());\n\nawait this.do("updateLambda", new LambdaResource().setArgument({\n    stackProps: {\n        parameterArn: paramOutput.parameterArn, // \u2705 Direct cross-account reference\n        env: { account: this.argument.accountB.id }\n    }\n}))\n'})}),"\n",(0,s.jsx)(n.p,{children:"The key difference? Orbits handles the cross-account coordination automatically, allowing you to reference resources naturally regardless of which account they live in."}),"\n",(0,s.jsx)(n.h2,{id:"hands-on-building-the-example",children:"Hands-On: Building the Example"}),"\n",(0,s.jsx)(n.p,{children:"The following section walks through building this cross-account parameter example step by step."}),"\n",(0,s.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(n.p,{children:"You'll need:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Access to two AWS accounts with CloudFormation deployment permissions"}),"\n",(0,s.jsx)(n.li,{children:"Node.js and npm installed"}),"\n",(0,s.jsx)(n.li,{children:"MongoDB instance for orbits state management"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"project-setup",children:"Project Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Clone the repository\ngit clone <repository-url>\ncd cross-account-example\n\n# Install dependencies\nnpm install\n\n# Configure environment\ncp .base.env .env\n# Edit .env with your account details\nvi .env\n"})}),"\n",(0,s.jsx)(n.h3,{id:"project-structure",children:"Project structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 orbits/\n\u2502   \u2502   \u2514\u2500\u2500 orbi.ts # Main orchestration script\n\u2502   \u2502   \u251c\u2500\u2500 lambda-resource.ts # lambda resource definition\n\u2502   \u2502   \u251c\u2500\u2500 param-resource.ts # Param resource definition\n\u2502   \u2502   \u251c\u2500\u2500 hello-resource.ts # Hello resource definition : the resource that make the junction between param and lambda\n\n\u2502   \u251c\u2500\u2500 cdk/              # CDK stack definitions\n\u2502   \u2502   \u251c\u2500\u2500 lambda.ts # lambda CDK stack\n\u2502   \u2502   \u251c\u2500\u2500 param.ts # Param CDK stack\n\u251c\u2500\u2500 .base.env                # Environment template\n\u251c\u2500\u2500 .env                     # Your environment variables (git-ignored)\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 README.md\n"})}),"\n",(0,s.jsx)(n.h3,{id:"the-resource-definitions",children:"The Resource Definitions"}),"\n",(0,s.jsx)(n.h4,{id:"lambda-and-param-cdk-stack",children:"Lambda and Param CDK Stack"}),"\n",(0,s.jsxs)(n.p,{children:["We focus on two stack ",(0,s.jsx)(n.code,{children:"LambdaStack"})," and ",(0,s.jsx)(n.code,{children:"ParameterStoreStack"}),"\n[link to the stack]"]}),"\n",(0,s.jsx)(n.h5,{id:"lambda-stack",children:"Lambda stack"}),"\n",(0,s.jsx)(n.p,{children:"A lambda that will display the value of the parameter passed in parameter if it can access it."}),"\n",(0,s.jsx)(n.h4,{id:"parameter-stack",children:"Parameter stack"}),"\n",(0,s.jsx)(n.p,{children:'A parameter store that stores an "hello-world" value.'}),"\n",(0,s.jsx)(n.h4,{id:"encapsulate-the-stacks-in-a-resource-definition",children:"Encapsulate the stacks in a resource definition."}),"\n",(0,s.jsx)(n.p,{children:"Here's what a CDK resource definitions look like:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Lambda Resource (lambda-resource.ts):"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="src/orbits/lambda-resource.ts"',children:'export class LambdaResource extends CdkStackResource{\n    \n    StackConstructor = LambdaStack;\n\n    declare IOutput : {\n        "roleArn": string\n    } \n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Let's go line by line."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"StackConstructor = LambdaStack"})," : this tells the orchestrator that ",(0,s.jsx)(n.code,{children:"LambdaResource"})," will use the ",(0,s.jsx)(n.code,{children:"LambdaStack"})," class constructor to define and manage its infrastructure."]}),"\n",(0,s.jsx)(n.li,{}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'declare IOutput : {\n        "roleArn": string\n} \n'})}),"\n",(0,s.jsx)(n.p,{children:'The CloudFormation stack for the Lambda function exports a single output: "roleArn", which is the ARN of the Lambda\'s execution role.\nThe IOutput declaration is used for type safety\u2014it informs the developer that this resource will expose an output matching that structure.'}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"If not already done, the CDK environment will be automatically bootstrapped by the CDKResource\u2014no other step is required, the fulllifecycle of your resource is managed."})}),"\n",(0,s.jsx)(n.h4,{id:"write-a-proxy-resource-to-orchestrate-both-lambda-and-param-deployment",children:"Write a proxy resource to orchestrate both lambda and param deployment"}),"\n",(0,s.jsxs)(n.p,{children:["We could choose different orchestrations stategies.\nHere we choose to have a proxy resources that deploy both the ",(0,s.jsx)(n.code,{children:"Param"})," and the ",(0,s.jsx)(n.code,{children:"Lambda"})," stack and that synchronize the use of both in coordination."]}),"\n",(0,s.jsx)(n.h5,{id:"install-step",children:"Install step"}),"\n",(0,s.jsxs)(n.p,{children:["During the first step, we launch a first deployment of the ",(0,s.jsx)(n.code,{children:"Lambda"})," stack.\nAt this step, the ",(0,s.jsx)(n.code,{children:"ParamStore"})," stack does not exist, so no optional properties are passed."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'src="src/orbits/hello-resource.ts"',children:'async defineInstall(){\n        await this.do("firstDeployLambda", this.constructLambdaResource());\n}\n\nconstructLambdaResource(){\n        return new LambdaResource().setArgument({\n            stackName: "lambda",\n            awsProfileName: this.argument.accountB.profile,\n            stackProps: {\n                env: {\n                    region: this.argument.region,\n                    account: this.argument.accountB.id\n                }\n            }\n        })\n}\n'})}),"\n",(0,s.jsx)(n.h5,{id:"update-step",children:"Update step"}),"\n",(0,s.jsxs)(n.p,{children:["When updating the resource, we deploy both the ",(0,s.jsx)(n.code,{children:"Param"})," and ",(0,s.jsx)(n.code,{children:"Lambda"})," stack."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'src="src/orbits/hello-resource.ts"',children:'async defineUpdate(){\n        const lambdaResource = this.constructLambdaResource();\n\n        const lambdaOutput = await this.do("getLambdaOutput", ()=>{\n            return lambdaResource.getResourceOutput();\n        })\n\n        const paramOutput = await this.do("updateParam", this.constructParamResource(lambdaOutput));\n\n        await this.do("updateLambda", this.constructLambdaResource(paramOutput))\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ParamResource"})," consumes the output of ",(0,s.jsx)(n.code,{children:"LambdaResource"})," and vice versa.\nAs a consequence, we need to refine the constructs methods."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'src="src/orbits/hello-resource.ts"',children:"    constructLambdaResource(paramOutput? : ParamResource['IOutput']){\n        return new LambdaResource().setArgument({\n            stackName: \"lambda\",\n            awsProfileName: this.argument.accountB.profile,\n            stackProps: {\n                accountARoleArn: paramOutput?.roleArn,\n                parameterArn: paramOutput?.paramArn,\n                env: {\n                    region: this.argument.region,\n                    account: this.argument.accountB.id\n                }\n            }\n        })\n    }\n\n    constructParamResource(lambdaOutput? : LambdaResource['IOutput']){\n        return new ParamResource().setArgument({\n            stackName: \"param\",\n            awsProfileName: this.argument.accountA.profile,\n            stackProps: {\n                accountBId: this.argument.accountB.id,\n                accountBRoleArn: lambdaOutput.roleArn,\n                env: {\n                    region: this.argument.region,\n                    account: this.argument.accountA.id\n                }\n            }\n        })\n    }\n"})}),"\n",(0,s.jsx)(n.h4,{id:"uninstall-step",children:"Uninstall step"}),"\n",(0,s.jsxs)(n.p,{children:["To uninstall, we uninstall both the ",(0,s.jsx)(n.code,{children:"Lambda"})," and ",(0,s.jsx)(n.code,{children:"ParamStore"})," stacks."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'src="src/orbits/hello-resource.ts"',children:'async defineUninstall(){\n        await this.do("uninstallLambda", this.constructLambdaResource().setCommand("Uninstall"));\n        await this.do("uninstallParam", this.constructParamResource().setCommand("Uninstall"))\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"deployment",children:"Deployment"}),"\n",(0,s.jsx)(n.p,{children:"The entire cross-account deployment happens with a single command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"export $(cat .env | xargs)\nexport ORBITS_DB__MONGO__URL=your-mongo-url\nnpx tsx src/orbits/orbi.ts\n"})}),"\n",(0,s.jsx)(n.p,{children:"This orchestrates:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Parameter deployment in Account A"}),"\n",(0,s.jsx)(n.li,{children:"Cross-account IAM policy setup"}),"\n",(0,s.jsx)(n.li,{children:"Lambda function deployment in Account B"}),"\n",(0,s.jsx)(n.li,{children:"All necessary permissions and configurations"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"verification",children:"Verification"}),"\n",(0,s.jsx)(n.p,{children:"After deployment, you can test the Lambda function in Account B. It will successfully retrieve the parameter from Account A, demonstrating seamless cross-account access."}),"\n",(0,s.jsx)(n.p,{children:"The Lambda logs will show:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Param: hello-world\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cleanup",children:"Cleanup"}),"\n",(0,s.jsx)(n.p,{children:"To remove all deployed resources from both accounts:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"export HELLO_COMMAND=uninstall\nnpx tsx src/orbits/orbi.ts\n"})}),"\n",(0,s.jsx)(n.p,{children:"\u26a0\ufe0f Warning: This will permanently delete all resources created by this example. Make sure you want to remove everything before running this command."}),"\n",(0,s.jsx)(n.h2,{id:"why-this-matters",children:"Why This Matters"}),"\n",(0,s.jsx)(n.p,{children:"This example might seem simple, but it represents a fundamental gain in how we think about multi-account architectures. Instead of treating cross-account access as an exception requiring special handling, orbits makes it a first-class citizen of your infrastructure-as-code workflow. It allows to completly automate cross-account resources definition."}),"\n",(0,s.jsx)(n.h3,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Declarative Cross-Account Resources:"})," Reference any resource from any account without manual coordination."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Automatic Permission Management:"})," IAM policies and resource policies are handled automatically."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Consistent Deployment Experience:"})," Multi-account deployments feel the same as single-account ones."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Simplified Maintenance:"})," Updates and changes don't require manual ARN extraction and policy coordination."]}),"\n",(0,s.jsx)(n.h2,{id:"looking-forward",children:"Looking Forward"}),"\n",(0,s.jsx)(n.p,{children:"Cross-account resource management shouldn't be a second-class citizen in your infrastructure-as-code workflow. Tools like orbits point toward a future where account boundaries enhance security without sacrificing developer experience."}),"\n",(0,s.jsx)(n.p,{children:"If you're building multi-account architectures, I encourage you to try this example and see how much simpler cross-account resource management can be. The days of manual ARN extraction and policy coordination don't have to be permanent fixtures of AWS multi-account architectures."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Ready to try it yourself? The complete example code and setup instructions are available in the repository. Give it a spin and share your experience with cross-account resource management."})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var a=t(6540);const s={},r=a.createContext(s);function o(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);