"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"programmable-cdk8s-deployment","metadata":{"permalink":"/blog/programmable-cdk8s-deployment","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-07-11-cdk8s-deployment.md","source":"@site/blog/2025-07-11-cdk8s-deployment.md","title":"Automate deployments of cdk8s template","description":"Cdk8s is a great tool to write your Kubernetes IaC templates using standard programming languages. But unlike the AWS cdk, which is tightly integrated with CloudFormation to manage stack deployment, cdk8s has no native deployment mechanism.","date":"2025-07-11T00:00:00.000Z","tags":[{"inline":true,"label":"cdk8s","permalink":"/blog/tags/cdk-8-s"},{"inline":true,"label":"orbits","permalink":"/blog/tags/orbits"},{"inline":true,"label":"model-driven orchestration","permalink":"/blog/tags/model-driven-orchestration"}],"readingTime":5.31,"hasTruncateMarker":true,"authors":[{"name":"Tom Marcuzzi","title":"Head of engineering @ Webcapsule","url":"https://linkedin.com/in/tom-marcuzzi","page":{"permalink":"/blog/authors/tom"},"socials":{"linkedin":"https://www.linkedin.com/in/tommarcuzzi/","github":"https://github.com/tommarcuzzi"},"imageURL":"/img/authors/tom.png","key":"tom"},{"name":"Louis Dussarps","title":"CEO @ Webcapsule","url":"https://github.com/louisdussarps","page":{"permalink":"/blog/authors/louis"},"socials":{"linkedin":"https://www.linkedin.com/in/louisdussarps/","github":"https://github.com/louisdussarps"},"imageURL":"/img/authors/louis.png","key":"louis"}],"frontMatter":{"slug":"programmable-cdk8s-deployment","title":"Automate deployments of cdk8s template","authors":["tom","louis"],"tags":["cdk8s","orbits","model-driven orchestration"]},"unlisted":false,"nextItem":{"title":"Solving cross-account resources for AWS CDK","permalink":"/blog/cross-account-cdk"}},"content":"[Cdk8s](https://cdk8s.io/) is a great tool to write your Kubernetes IaC templates using standard programming languages. But unlike the [AWS cdk](https://aws.amazon.com/fr/cdk/), which is tightly integrated with CloudFormation to manage stack deployment, cdk8s has no native deployment mechanism.\\n\\nBy default, it allows you to synthesize manifests and deploy them using `kubectl apply`, or optionally through [Helm](https://helm.sh/). While both approaches can work, they often fall short for more advanced use cases \u2014 for example, when you want to programmatically chain deployments, export values from the chart, or implement a custom rollback and prune strategy.\\n\\nIn this blog post, we\u2019ll explain how we built a model-driven orchestrator for cdk8s using Orbits \u2014 a lightweight framework for orchestrating cloud resources and workflows. We\u2019ll show how you can use it, adapt it to your own needs, or even build your own orchestrator based on the same principles. If Orbits fits your use case, you can directly reuse what we\u2019ve built.\\n\x3c!-- truncate --\x3e\\n\\n## The Need for cdk8s orchestration\\n\\nThere is no built-in way to programmatically and reliably deploy a cdk8s stack \u2014 especially outside of the AWS ecosystem.\\n\\nThe current options are:\\n- Synthesize the stack and apply it with `kubectl apply`\\n- Deploy the stack as a Helm chart\\n\\nBut both of these have shortcomings:\\n- They are not easily orchestrated programmatically \\n- Helm has known limitations when integrating with cdk8s\\n- There\u2019s no native support for retries, failover, or rollback\\n- There is no built-in mechanism to chain the deployment of multiple charts, especially if some charts are on one kube cluster and other on another kube cluster\\n- Helm\u2019s rollback model didn\u2019t align with our platform needs\\n\\nIn our case \u2014 building internal platforms for highly regulated environments \u2014 we needed more control. Our deployment flow had to:\\n- Configure cloud provider resources via API calls\\n- Deploy multiple charts programmatically in a precise order\\n- Use the results of deployments (like IPs or service names) to configure other infrastructure components\\n\\nGiven these needs, existing options were simply not enough.\\nWhat we were looking for resembled the CloudFormation model:\\n- Attempt a deployment\\n- Rollback to the previous state on failure\\n- On success, prune obsolete resources\\n- Output values that could be reused in subsequent steps\\n\\nAdditionally, we needed:\\n- Safe concurrent executions, to allow multiple deployments at the same time without conflict\\n- Built-in retry policies for transient failures\\n\\nThese requirements led us to build a dedicated orchestrator for cdk8s using Orbits \u2014 a model-driven orchestration engine designed for reliability and composability.\\n\\n## Final result\\n\\nThe result is an Orbits resource that manages your cdk8s deployment.\\nYou can read the [orbits documentation](/documentation/helper/integrations/cdk8s-resource) on how to use it.\\n\\n- You can use it by extending the base class:\\n```typescript\\nexport class BasicResource extends Cdk8sResource {\\n  StackConstructor = BasicChart ;\\n}\\n```\\n\\n- Or dynamically assign a custom stack generation method:\\n```typescript\\nconst myCdk8sResource = new Cdk8sResource();\\nmyCdk8sResource.generateStack = ()=>{\\n    return new cdk8s.Chart(myCdk8sResource.app, \'empty-chart\')\\n}\\n\\nawait this.do(\\"update-stack\\", {dynamicAction: myCdk8sResource});\\n```\\n\\n:::info Outputs \\nyou can export outputs, which allows you to chain charts or propagate values (like an IP address for DNS updates)\\n\\n```typescript\\nasync setOutput(){\\n        const stack = await this.generateStack();\\n        const apiServiceInfo = await this.kubeApi.coreApi.readNamespacedService({\\n            name: stack.loadBalancerService.name,\\n            namespace: stack.loadBalancerService.metadata.namespace || \'default\',\\n        })\\n        return apiServiceInfo.status.loadBalancer.ingress[0].ip;\\n}\\n```\\n:::\\n\\n:::info Concurrency\\nConcurrency is also managed by Orbits. If a deployment is already running, concurrent executions will be serialized to prevent state corruption\\n```typescript\\n    //somewhere\\n    this.do(\\"deploy\\", new MyBasicChartResource())\\n    //elsewhere\\n    this.do(\\"deploy\\", new MyBasicChartResource())\\n```\\nThe two deployments will [coalesce](/documentation/core-concepts/resource#convergent-execution-coalescing).\\n:::\\n\\n:::info Crash-proof\\nOrbits is [crash-proof](/documentation/quick-start#workflow-a-chain-of-actions).\\nIf a crash occurs mid-deployment, Orbits will resume from the same step on restart.\\n:::\\n\\n## Implementation\\n\\nFrom a cdk8s chart, we want to:\\n- Deploy the chart reliably\\n- Retry on failure\\n- Rollback to the previous state if necessary\\n- Prune obsolete resources\\n\\n### The orbits Cdk8s resources\\n\\nIn Orbits, [resources](/documentation/core-concepts/resources) are stateful units that define hooks like defineUpdate.\\nFor the deployment of a cdk8s chart, we only need the `update` hook.\\nThe high-level flow of the resource implementation is as follows:\\n\\n```typescript \\nexport class Cdk8sResource{\\n    \\n    defineUpdate(){\\n        try{\\n            await this.do(\\"deploy\\", ...)\\n        }\\n        catch(err){\\n            this.bag.rollBackNeeded = true;\\n            await this.do(\\"rollback\\", ...)\\n        }\\n        finally{\\n            await this.do(\\"prune\\", ...)\\n        }\\n\\n        if(!this.bag.rollBackNeeded){\\n            await this.do(\\"storeNewChart\\", ...)\\n        }\\n    }\\n}\\n```\\n\\n```mermaid\\nflowchart TD\\n    Start[\\"Start\\"] --\x3e Deploy[\\"Deploy\\"]\\n    Deploy -- Success --\x3e FinallyPrune[\\"Prune\\"]\\n    Deploy -- Error --\x3e SetRollback[\\"Rollback\\"]\\n    SetRollback --\x3e FinallyPrune\\n    FinallyPrune --\x3e CheckRollbackFlag[\\"Deploy has been a success?\\"]\\n    CheckRollbackFlag -- Yes --\x3e Store[\\"Store new chart\\"]\\n    Store --\x3e End[\\"End\\"]\\n    CheckRollbackFlag -- No --\x3e End\\n\\n    CheckRollbackFlag@{ shape: rounded}\\n```\\n\\nThe complete implementation is available [here on github](https://github.com/LaWebcapsule/orbits/blob/main/helpers/src/standards-resource/cdk8s/cdk8s-resource.ts)\\n\\n#### Deploying the chart\\n\\nThere are multiple ways to deploy a stack, but we chose `kubectl apply` because it updates only the resources that changed. That means kubectl is required in the environment running the deployment.\\n\\n#### Ensuring the deployment is a success\\n\\nWe don\u2019t just fire and forget. We verify that critical resources are ready:\\n- All Deployments reach a ready state\\n- Certificates (e.g., from cert-manager) are marked as ready\\nThis check helps us ensure the cluster is in a stable and usable state before moving forward.\\n\\n#### Storing the latest chart\\n\\nWe store the chart contents in a Kubernetes Secret. The secret\u2019s name is generated based on the stack name:\\n```typescript\\nprivate genSecretName(): string {\\n        return `orbits.deployment.${this.argument.stackName}`;\\n}\\n```\\nThis allows the system to compare the current state with the previous one during rollback or pruning.\\n\\n#### Pruning unused resources\\n\\nPruning depends on whether the deployment succeeded:\\n- On success, we prune old resources\\n- On failure, we prune newly created resources\\n\\nWe compare the list of objects in the stored stack with the current state and remove the unneeded ones.\\nWe make sure to never delete:\\n- Namespaces\\n- PersistentVolumeClaims\\n\\n\\n### Key Benefits\\n\\n- CloudFormation-like rollback for Cdk8s chart\\n- Crash-safe and retryable deployments\\n- Safe concurrent operations\\n- Outputs and dependency chaining support\\n- Multi-tenants deployment support\\n\\n\\n## Looking Forward\\n\\nOur orchestrator provides a robust and flexible foundation for managing cdk8s deployments in production. While it already solves some pain points, we plan to improve:\\n- Improved diff tools to preview changes before applying them\\n- Extended tracking and monitoring of additional Kubernetes resources\\nAdditionally, the resource offers a promising starting point for implementing drift detection, but that topic will be covered in a future post.\\n\\n---\\n\\n*The source code of the CDk8SResource is available here: [https://github.com/LaWebcapsule/orbits/blob/main/helpers/src/standards-resource/cdk8s/cdk8s-resource.ts](https://github.com/LaWebcapsule/orbits/blob/main/helpers/src/standards-resource/cdk8s/cdk8s-resource.ts)*"},{"id":"cross-account-cdk","metadata":{"permalink":"/blog/cross-account-cdk","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-06-25-cross-account-cdk.md","source":"@site/blog/2025-06-25-cross-account-cdk.md","title":"Solving cross-account resources for AWS CDK","description":"If you\'ve ever tried to build a multi-account AWS architecture using CDK or CloudFormation, you\'ve probably hit the same frustrating wall: cross-account resource references don\'t work without manual coordination and hardcoded values. What should be a simple task\u2014like reading a parameter from Account A in a Lambda function deployed to Account B\u2014becomes a tedious manual process. This behaviour is already documented and while AWS also documents workarounds, there\u2019s no indication that this is going to change anytime soon. However, these approaches don\'t scale when you have multiple services and resources spanning different accounts across your organization.","date":"2025-06-25T00:00:00.000Z","tags":[{"inline":true,"label":"aws-cdk","permalink":"/blog/tags/aws-cdk"},{"inline":true,"label":"orbits","permalink":"/blog/tags/orbits"}],"readingTime":6.81,"hasTruncateMarker":true,"authors":[{"name":"Louis Dussarps","title":"CEO @ Webcapsule","url":"https://github.com/louisdussarps","page":{"permalink":"/blog/authors/louis"},"socials":{"linkedin":"https://www.linkedin.com/in/louisdussarps/","github":"https://github.com/louisdussarps"},"imageURL":"/img/authors/louis.png","key":"louis"}],"frontMatter":{"slug":"cross-account-cdk","title":"Solving cross-account resources for AWS CDK","authors":["louis"],"tags":["aws-cdk","orbits"]},"unlisted":false,"prevItem":{"title":"Automate deployments of cdk8s template","permalink":"/blog/programmable-cdk8s-deployment"},"nextItem":{"title":"Infra is code","permalink":"/blog/manifesto"}},"content":"If you\'ve ever tried to build a multi-account AWS architecture using CDK or CloudFormation, you\'ve probably hit the same frustrating wall: cross-account resource references don\'t work without manual coordination and hardcoded values. What should be a simple task\u2014like reading a parameter from Account A in a Lambda function deployed to Account B\u2014becomes a tedious manual process. This behaviour is already [documented](https://www.luminis.eu/blog/cross-account-aws-resource-access-with-aws-cdk/) and while AWS also documents [workarounds](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/walkthrough-crossstackref.html), there\u2019s no indication that this is going to change anytime soon. However, these approaches don\'t scale when you have multiple services and resources spanning different accounts across your organization.\\n\\nThis post walks through a practical example that demonstrates both the problem and a solution using orbits, a tool designed to seamless orchestrate all of your IaC with code.\\n\\n\x3c!-- truncate --\x3e\\n## The Cross-Account Problem\\n\\nAWS CDK and CloudFormation have a limitation: stacks cannot directly reference resources from other AWS accounts. This creates friction for common architectural patterns like:\\n\\n- Sharing Docker images between development and production accounts\\n- Accessing centralized secrets from distributed applications\\n- Setting up VPC peering connections\\n- Managing cross-account S3 bucket permissions\\n- Distributing Lambda layers across organizational boundaries\\n\\nHere\'s what this limitation looks like in practice:\\n\\n```typescript\\nconst app = new cdk.App()\\n\\nconst paramA = new ParamStack(app, \'stack-A\', {\\n    env: { account: \\"account-A\\" }\\n})\\n\\nconst lambdaB = new LambdaStack(app, \'stack-B\', {\\n    parameterArn: paramA.parameter.arn, // \u274c This fails at synthesis time\\n    env: { account: \\"account-B\\" }\\n})\\n```\\n\\nThe traditional workaround involves manual steps: extracting ARNs, hardcoding values, coordinating resource policies, and deploying in specific sequences. This breaks the declarative nature of infrastructure-as-code and makes architectures brittle.\\n\\n## A Real-World Example\\n\\nHere\'s an \\"hello-world\\" scenario to illustrate the problem: deploying an AWS Systems Manager parameter in Account A and reading it from a Lambda function in Account B. While the \\"cross-account sharing\\" feature for AWS SSM parameter could be used, this simple use case illustrates the broader challenge perfectly.\\n\\n### The Traditional CDK Approach (Doesn\'t scale)\\n\\nWith standard CDK, you\'d need to:\\n\\n1. Deploy the parameter stack in Account A\\n2. Manually extract the parameter ARN\\n3. Hardcode the ARN into your Lambda stack for Account B\\n4. Manually configure cross-account IAM policies\\n5. Deploy the Lambda stack in Account B\\n6. Hope nothing changes, because updates require repeating this process\\n\\n### The Orchestration Solution with orbits\\n\\nWith orbits, the same architecture becomes straightforward:\\n\\n```typescript\\nconst paramOutput = await this.do(\\"updateParam\\", new ParamResource());\\n\\nawait this.do(\\"updateLambda\\", new LambdaResource().setArgument({\\n    stackProps: {\\n        parameterArn: paramOutput.parameterArn, // \u2705 Direct cross-account reference\\n        env: { account: this.argument.accountB.id }\\n    }\\n}))\\n```\\n\\nThe key difference? Orbits handles the cross-account coordination automatically, allowing you to reference resources naturally regardless of which account they live in.\\n\\n## Hands-On: Building the Example\\n\\nThe following section walks through building this cross-account parameter example step by step.\\n\\n### Prerequisites\\n\\nYou\'ll need:\\n- Access to two AWS accounts with CloudFormation deployment permissions\\n- Node.js and npm installed\\n- MongoDB instance for orbits state management\\n\\n### Project Setup\\n\\n```bash\\n# Clone the repository\\ngit clone <repository-url>\\ncd cross-account-example\\n\\n# Install dependencies\\nnpm install\\n\\n# Configure environment\\ncp .base.env .env\\n# Edit .env with your account details\\nvi .env\\n```\\n\\n### Project structure\\n\\n```bash\\n\u251c\u2500\u2500 src/\\n\u2502   \u251c\u2500\u2500 orbits/\\n\u2502   \u2502   \u2514\u2500\u2500 orbi.ts # Main orchestration script\\n\u2502   \u2502   \u251c\u2500\u2500 lambda-resource.ts # lambda resource definition\\n\u2502   \u2502   \u251c\u2500\u2500 param-resource.ts # Param resource definition\\n\u2502   \u2502   \u251c\u2500\u2500 hello-resource.ts # Hello resource definition : the resource that make the junction between param and lambda\\n\\n\u2502   \u251c\u2500\u2500 cdk/              # CDK stack definitions\\n\u2502   \u2502   \u251c\u2500\u2500 lambda.ts # lambda CDK stack\\n\u2502   \u2502   \u251c\u2500\u2500 param.ts # Param CDK stack\\n\u251c\u2500\u2500 .base.env                # Environment template\\n\u251c\u2500\u2500 .env                     # Your environment variables (git-ignored)\\n\u251c\u2500\u2500 package.json\\n\u2514\u2500\u2500 README.md\\n```\\n\\n### The Resource Definitions\\n\\n#### Lambda and Param CDK Stack\\n\\nWe focus on two stack `LambdaStack` and `ParameterStoreStack`\\n[link to the stack]\\n\\n##### Lambda stack\\n\\nA lambda that will display the value of the parameter passed in parameter if it can access it.\\n\\n#### Parameter stack\\n\\nA parameter store that stores an \\"hello-world\\" value.\\n\\n\\n#### Encapsulate the stacks in a resource definition.\\n\\nHere\'s what a CDK resource definitions look like:\\n\\n\\n**Lambda Resource (lambda-resource.ts):**\\n```typescript title=\\"src/orbits/lambda-resource.ts\\"\\nexport class LambdaResource extends CdkStackResource{\\n    \\n    StackConstructor = LambdaStack;\\n\\n    declare IOutput : {\\n        \\"roleArn\\": string\\n    } \\n}\\n```\\n\\nLet\'s go line by line.\\n- `StackConstructor = LambdaStack` : this tells the orchestrator that `LambdaResource` will use the `LambdaStack` class constructor to define and manage its infrastructure.\\n- \\n```typescript \\ndeclare IOutput : {\\n        \\"roleArn\\": string\\n} \\n```\\nThe CloudFormation stack for the Lambda function exports a single output: \\"roleArn\\", which is the ARN of the Lambda\'s execution role.\\nThe IOutput declaration is used for type safety\u2014it informs the developer that this resource will expose an output matching that structure.\\n\\n:::info\\nIf not already done, the CDK environment will be automatically bootstrapped by the CDKResource\u2014no other step is required, the fulllifecycle of your resource is managed.\\n:::\\n\\n#### Write a proxy resource to orchestrate both lambda and param deployment\\n\\nWe could choose different orchestrations stategies.\\nHere we choose to have a proxy resources that deploy both the `Param` and the `Lambda` stack and that synchronize the use of both in coordination.\\n\\n##### Install step\\n\\nDuring the first step, we launch a first deployment of the `Lambda` stack.\\nAt this step, the `ParamStore` stack does not exist, so no optional properties are passed.\\n```typescript src=\\"src/orbits/hello-resource.ts\\"\\nasync defineInstall(){\\n        await this.do(\\"firstDeployLambda\\", this.constructLambdaResource());\\n}\\n\\nconstructLambdaResource(){\\n        return new LambdaResource().setArgument({\\n            stackName: \\"lambda\\",\\n            awsProfileName: this.argument.accountB.profile,\\n            stackProps: {\\n                env: {\\n                    region: this.argument.region,\\n                    account: this.argument.accountB.id\\n                }\\n            }\\n        })\\n}\\n```\\n\\n##### Update step\\n\\nWhen updating the resource, we deploy both the `Param` and `Lambda` stack.\\n```typescript src=\\"src/orbits/hello-resource.ts\\"\\nasync defineUpdate(){\\n        const lambdaResource = this.constructLambdaResource();\\n\\n        const lambdaOutput = await this.do(\\"getLambdaOutput\\", ()=>{\\n            return lambdaResource.getResourceOutput();\\n        })\\n\\n        const paramOutput = await this.do(\\"updateParam\\", this.constructParamResource(lambdaOutput));\\n\\n        await this.do(\\"updateLambda\\", this.constructLambdaResource(paramOutput))\\n}\\n```\\n\\n`ParamResource` consumes the output of `LambdaResource` and vice versa.\\nAs a consequence, we need to refine the constructs methods.\\n\\n```typescript src=\\"src/orbits/hello-resource.ts\\"\\n    constructLambdaResource(paramOutput? : ParamResource[\'IOutput\']){\\n        return new LambdaResource().setArgument({\\n            stackName: \\"lambda\\",\\n            awsProfileName: this.argument.accountB.profile,\\n            stackProps: {\\n                accountARoleArn: paramOutput?.roleArn,\\n                parameterArn: paramOutput?.paramArn,\\n                env: {\\n                    region: this.argument.region,\\n                    account: this.argument.accountB.id\\n                }\\n            }\\n        })\\n    }\\n\\n    constructParamResource(lambdaOutput? : LambdaResource[\'IOutput\']){\\n        return new ParamResource().setArgument({\\n            stackName: \\"param\\",\\n            awsProfileName: this.argument.accountA.profile,\\n            stackProps: {\\n                accountBId: this.argument.accountB.id,\\n                accountBRoleArn: lambdaOutput.roleArn,\\n                env: {\\n                    region: this.argument.region,\\n                    account: this.argument.accountA.id\\n                }\\n            }\\n        })\\n    }\\n```\\n\\n#### Uninstall step\\n\\nTo uninstall, we uninstall both the `Lambda` and `ParamStore` stacks.\\n\\n```typescript src=\\"src/orbits/hello-resource.ts\\"\\nasync defineUninstall(){\\n        await this.do(\\"uninstallLambda\\", this.constructLambdaResource().setCommand(\\"Uninstall\\"));\\n        await this.do(\\"uninstallParam\\", this.constructParamResource().setCommand(\\"Uninstall\\"))\\n}\\n```\\n\\n\\n### Deployment\\n\\nThe entire cross-account deployment happens with a single command:\\n\\n```bash\\nexport $(cat .env | xargs)\\nexport ORBITS_DB__MONGO__URL=your-mongo-url\\nnpx tsx src/orbits/orbi.ts\\n```\\n\\nThis orchestrates:\\n1. Parameter deployment in Account A\\n2. Cross-account IAM policy setup\\n3. Lambda function deployment in Account B\\n4. All necessary permissions and configurations\\n\\n#### Verification\\n\\nAfter deployment, you can test the Lambda function in Account B. It will successfully retrieve the parameter from Account A, demonstrating seamless cross-account access.\\n\\nThe Lambda logs will show:\\n```\\nParam: hello-world\\n```\\n\\n\\n### Cleanup\\nTo remove all deployed resources from both accounts:\\n```bash\\nexport HELLO_COMMAND=uninstall\\nnpx tsx src/orbits/orbi.ts\\n```\\n\u26a0\ufe0f Warning: This will permanently delete all resources created by this example. Make sure you want to remove everything before running this command.\\n\\n## Why This Matters\\n\\nThis example might seem simple, but it represents a fundamental gain in how we think about multi-account architectures. Instead of treating cross-account access as an exception requiring special handling, orbits makes it a first-class citizen of your infrastructure-as-code workflow. It allows to completly automate cross-account resources definition.\\n\\n### Key Benefits\\n\\n**Declarative Cross-Account Resources:** Reference any resource from any account without manual coordination.\\n\\n**Automatic Permission Management:** IAM policies and resource policies are handled automatically.\\n\\n**Consistent Deployment Experience:** Multi-account deployments feel the same as single-account ones.\\n\\n**Simplified Maintenance:** Updates and changes don\'t require manual ARN extraction and policy coordination.\\n\\n## Looking Forward\\n\\nCross-account resource management shouldn\'t be a second-class citizen in your infrastructure-as-code workflow. Tools like orbits point toward a future where account boundaries enhance security without sacrificing developer experience.\\n\\nIf you\'re building multi-account architectures, I encourage you to try this example and see how much simpler cross-account resource management can be. The days of manual ARN extraction and policy coordination don\'t have to be permanent fixtures of AWS multi-account architectures.\\n\\n---\\n\\n*Ready to try it yourself? The complete example code and setup instructions are available in the repository. Give it a spin and share your experience with cross-account resource management.*"},{"id":"manifesto","metadata":{"permalink":"/blog/manifesto","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-06-04-manifesto.md","source":"@site/blog/2025-06-04-manifesto.md","title":"Infra is code","description":"Infra is code!","date":"2025-06-04T00:00:00.000Z","tags":[{"inline":true,"label":"manifesto","permalink":"/blog/tags/manifesto"},{"inline":true,"label":"orbits","permalink":"/blog/tags/orbits"}],"readingTime":2.81,"hasTruncateMarker":false,"authors":[{"name":"Louis Dussarps","title":"CEO @ Webcapsule","url":"https://github.com/louisdussarps","page":{"permalink":"/blog/authors/louis"},"socials":{"linkedin":"https://www.linkedin.com/in/louisdussarps/","github":"https://github.com/louisdussarps"},"imageURL":"/img/authors/louis.png","key":"louis"},{"name":"Lo\xefc D\xe9champs","title":"CTO @ Webcapsule","url":"https://github.com/ldechamps","page":{"permalink":"/blog/authors/loic"},"socials":{"linkedin":"https://www.linkedin.com/in/loicdechamps/","github":"https://github.com/ldechamps"},"imageURL":"/img/authors/loic.png","key":"loic"},{"name":"Arthur Rouzoul","title":"COO @ Webcapsule","url":"https://linkedin.com/in/arthurrouzoul","page":{"permalink":"/blog/authors/arthur"},"socials":{"linkedin":"https://www.linkedin.com/in/arthurrouzoul/","github":"https://github.com/Grouzoul"},"imageURL":"/img/authors/arthur.png","key":"arthur"},{"name":"Tom Marcuzzi","title":"Head of engineering @ Webcapsule","url":"https://linkedin.com/in/tom-marcuzzi","page":{"permalink":"/blog/authors/tom"},"socials":{"linkedin":"https://www.linkedin.com/in/tommarcuzzi/","github":"https://github.com/tommarcuzzi"},"imageURL":"/img/authors/tom.png","key":"tom"},{"name":"Sofia Chakir","title":"Head of cybersecurity @ Webcapsule","url":"https://linkedin.com/in/sofia-chakir","page":{"permalink":"/blog/authors/sofia"},"socials":{"linkedin":"https://www.linkedin.com/in/sofiachakir/","github":"https://github.com/sofiachakir"},"imageURL":"/img/authors/sofia.png","key":"sofia"}],"frontMatter":{"slug":"manifesto","title":"Infra is code","authors":["louis","loic","arthur","tom","sofia"],"tags":["manifesto","orbits"]},"unlisted":false,"prevItem":{"title":"Solving cross-account resources for AWS CDK","permalink":"/blog/cross-account-cdk"}},"content":"*Infra is code!*\\nAt first glance, this slogan might be the most stupid one ever read for a long time \u2014 if not on the entire planet, then at least in the web sphere. Yes, infrastructure has always been code: from the Ubuntu web server to the Cockroach database, it is nothing but code controlled by code. But if the Ops field has progressively shifted towards the notion of Infrastructure as Code, it is precisely because there is a substantial difference: the DevOps domain is better formalized as a description of reproducible artifacts rather than as a prescription of successive commands to execute.\\nThus, boldly displaying this slogan *Infra is code!* on any article should make any somewhat experienced DevOps practitioner pause.\\n\\nYet, friend reading these lines, don\u2019t go away so quickly! Haven\u2019t you already felt that while DevOps improved developers\u2019 lives with democratization of virtualization, convergence of interfaces, and unprecedented deployment speed, infrastructure itself remained, tucked away in some Git annex, a poor relative of computer code \u2014 difficult to edit, inflexible, and slow to test?\\nThe popular wisdom among developers seems to say: the less you touch infrastructure, the better off you are.\\nWith this, tirelessly, we arrive at a state-of-the-art where:\\n\\n- every project [restarts infrastructure work](https://www.reddit.com/r/devops/comments/1l8dsax/whats_eating_up_most_of_your_time_as_a_devops/) as if its neighbor didn\u2019t exist\\n- building a service stack remains a patchwork, a [conglomerate of loosely connected elements](https://www.tandfonline.com/doi/full/10.1080/17530350.2023.2229347)\\n- it is difficult, [without manual intervention, to redeploy an app from scratch on a new environment](https://insights.sei.cmu.edu/documents/576/2019_019_001_539335.pdf).\\n- apps are [hardly portable from one cloud to another](https://theses.hal.science/tel-02798770/file/90479_BRABRA_2020_archivage-4.pdf) \u2014 and the question of sovereignty is, out of frustration, abandoned.\\n\\nFinally, all in all, a large part of DevOps activity remains manual, and the trust chain in the system relies on a chain of responsibility and a comprehensive understanding of the system by a few operators in the team (which is positive) rather than on appropriate tooling (which is disappointing because, as system complexity grows, [relying solely on knowledge leads to rigid systems](https://link.springer.com/chapter/10.1007/978-3-319-74183-3_4)).\\n\\nConsequently, we unanimously demand that infrastructure specifications have the same rights and level of citizenship as any other piece of code in the stack.\\n\\nA demand that could remain dead letter if it were not accompanied by two recommendations:\\n\\norchestrators offer infrastructure an opportunity for liberation that it can seize to obtain its citizenship rights. The engineering platform movement has made a strong commitment in this direction and orchestration must be at the center of efforts.\\n\\nincreasingly, infrastructure benefits from being written in standard code: CDKs bear witness to the direction to follow. This allows a convergence of best practices between infrastructure and code.\\n\\nThus, IaC must be enhanced, orchestrated, and managed \u2014 as much as possible through standard code.\\nWe began working under these assumptions three years ago, and it has allowed us to build numerous engineering platforms since then. As we found nothing that met our criteria, we built our own orchestration framework: Orbits (aka Orbi.ts).\\nIt is now mature enough to fly on its own: since freedom is not won alone, we present it today to the community, hoping it can help build infrastructures and deployment pipelines that are more flexible, more robust, and more sovereign."}]}}')}}]);