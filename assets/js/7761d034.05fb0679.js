"use strict";(self.webpackChunkorbits_doc=self.webpackChunkorbits_doc||[]).push([[5243],{3224:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"documentation/core-concepts/agent","title":"Agent","description":"A Agent is a specialized type of Workflow designed to orchestrate the lifecycle of real-world entities, such as cloud accounts, services, or data systems. Agents provide a declarative and persistent way to manage these entities through versioning, reconciliation, shared state, and scheduled verification.","source":"@site/docs/documentation/core-concepts/agent.md","sourceDirName":"documentation/core-concepts","slug":"/documentation/core-concepts/agent","permalink":"/documentation/core-concepts/agent","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Agent","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Workflow","permalink":"/documentation/core-concepts/workflow"},"next":{"title":"Environment variables and runtime","permalink":"/documentation/core-concepts/runtime"}}');var c=t(4848),i=t(8453);const a={title:"Agent",sidebar_position:3},o="Agent documentation",r={},d=[{value:"Write a Agent",id:"write-a-agent",level:2},{value:"The <code>identity</code> of a agent",id:"the-identity-of-a-agent",level:3},{value:"Persistent storage for agents",id:"persistent-storage-for-agents",level:4},{value:"Agent output",id:"agent-output",level:4},{value:"Agent lifecycle commands",id:"agent-lifecycle-commands",level:3},{value:"Install hook",id:"install-hook",level:4},{value:"Update",id:"update",level:4},{value:"Uninstall",id:"uninstall",level:4},{value:"Cycle",id:"cycle",level:4},{value:"Using agents in a workflow",id:"using-agents-in-a-workflow",level:4},{value:"Custom Hooks",id:"custom-hooks",level:4},{value:"Convergent Execution (Coalescing)",id:"convergent-execution-coalescing",level:3},{value:"Divergent Execution (lock)",id:"divergent-execution-lock",level:3},{value:"Digest method",id:"digest-method",level:3}];function l(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"agent-documentation",children:"Agent documentation"})}),"\n",(0,c.jsx)(n.p,{children:"A Agent is a specialized type of Workflow designed to orchestrate the lifecycle of real-world entities, such as cloud accounts, services, or data systems. Agents provide a declarative and persistent way to manage these entities through versioning, reconciliation, shared state, and scheduled verification."}),"\n",(0,c.jsx)(n.p,{children:"Agents offer:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Retroactive control loops;"}),"\n",(0,c.jsx)(n.li,{children:"Shared workflow state via identity;"}),"\n",(0,c.jsx)(n.li,{children:"Output reuse across executions;"}),"\n",(0,c.jsx)(n.li,{children:"Hookable lifecycle stages: install, update, uninstall, and cycle."}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"write-a-agent",children:"Write a Agent"}),"\n",(0,c.jsxs)(n.p,{children:["A Agent is a ",(0,c.jsx)(n.code,{children:"Workflow"})," with some specials behaviors."]}),"\n",(0,c.jsxs)(n.h3,{id:"the-identity-of-a-agent",children:["The ",(0,c.jsx)(n.code,{children:"identity"})," of a agent"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export class MyAgent extends Agent {\n    IArgument: {\n        accountId: string;\n    };\n\n    identity() {\n        return this.argument.accountId;\n    }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"The identity() method defines a unique key for the agent. All agent instances with the same constructor and identity value will share the same database document, lifecycle state, and output."}),"\n",(0,c.jsx)(n.p,{children:"This enables deduplication and stateful coordination between concurrent invocations."}),"\n",(0,c.jsx)(n.h4,{id:"persistent-storage-for-agents",children:"Persistent storage for agents"}),"\n",(0,c.jsxs)(n.p,{children:["Each agent is backed by a shared database document, accessible via the ",(0,c.jsx)(n.code,{children:"agentDbDoc"})," property.\nSome properties of the document are internal to the framework and should not be modified unless you know what you are doing."]}),"\n",(0,c.jsx)(n.h4,{id:"agent-output",children:"Agent output"}),"\n",(0,c.jsxs)(n.p,{children:["Each agent can define an output with the ",(0,c.jsx)(n.code,{children:"setOutput"})," method.\nOutputs are stored persistently and are available to other workflows or agent cycles."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export class MyAgent extends Agent {\n    IArgument: {\n        accountId: string;\n    };\n\n    identity() {\n        return this.argument.accountId;\n    }\n\n    setOutput() {\n        return {\n            x: 1,\n        };\n    }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"Outputs can then be consumed by other workflows or agents:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export class MySecondAgent extends Agent {\n    IArgument: {\n        accountId: string;\n    };\n\n    identity() {\n        return this.argument.accountId;\n    }\n\n    setOutput() {\n        return {\n            x: 1,\n        };\n    }\n\n    async defineUpdate() {\n        const output = await this.do(\n            'get-output',\n            new MyAgent().setArgument({\n                accountId: this.argument.accountId,\n            }).getAgentOutput\n        );\n        await this.do('deploy', () => {\n            return new Service(output).create();\n        });\n    }\n}\n"})}),"\n",(0,c.jsx)(n.h3,{id:"agent-lifecycle-commands",children:"Agent lifecycle commands"}),"\n",(0,c.jsxs)(n.p,{children:["Agents define lifecycle hooks. These correspond to specific ",(0,c.jsx)(n.code,{children:"setCommand()"})," values and are executed based on state or schedule."]}),"\n",(0,c.jsx)(n.h4,{id:"install-hook",children:"Install hook"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export class MyAgent extends Agent {\n    IArgument: {\n        accountId: string;\n    };\n\n    identity() {\n        return this.argument.accountId;\n    }\n\n    version = '1.0.0';\n\n    async defineInstall() {\n        const myAccount = new Account();\n        await this.do('bootstrap', myAccount);\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"defineInstall"})," runs:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"when the agent has never been installed before;"}),"\n",(0,c.jsx)(n.li,{children:"when the version field changes;"}),"\n",(0,c.jsxs)(n.li,{children:["when explicitly triggered with ",(0,c.jsx)(n.code,{children:'.setCommand("install")'}),"."]}),"\n"]}),"\n",(0,c.jsx)(n.h4,{id:"update",children:"Update"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export class MyAgent extends Agent {\n    IArgument: {\n        accountId: string;\n    };\n\n    identity() {\n        return this.argument.accountId;\n    }\n\n    version = '1.0.0';\n\n    async defineInstall() {\n        const myAccount = new Account();\n        await this.do('bootstrap', myAccount);\n    }\n\n    async defineUpdate() {\n        const service = new Service().setArgument({\n            accountId: this.argument.accountId,\n        });\n        await this.do('launchService', service);\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"defineUpdate"})," runs:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"every time a default execution runs;"}),"\n",(0,c.jsxs)(n.li,{children:["if you force the execution of the ",(0,c.jsx)(n.code,{children:"update"})," step using ",(0,c.jsx)(n.code,{children:".setCommand('update')"})]}),"\n"]}),"\n",(0,c.jsx)(n.h4,{id:"uninstall",children:"Uninstall"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export class MyAgent extends Agent {\n    IArgument: {\n        accountId: string;\n    };\n\n    identity() {\n        return this.argument.accountId;\n    }\n\n    version = '1.0.0';\n\n    async defineInstall() {\n        const myAccount = new Account();\n        await this.do('bootstrap', myAccount);\n    }\n\n    async defineUpdate() {\n        const service = new Service().setArgument({\n            accountId: this.argument.accountId,\n        });\n        await this.do('launchService', () => {\n            return service.create();\n        });\n    }\n\n    async defineUninstall() {\n        const service = new Service().setArgument({\n            accountId: this.argument.accountId,\n        });\n        await this.do('launchService', () => {\n            return service.delete();\n        });\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"defineUninstall()"})," runs only if explicitly triggered with ",(0,c.jsx)(n.code,{children:'.setCommand("uninstall")'})]}),"\n",(0,c.jsx)(n.h4,{id:"cycle",children:"Cycle"}),"\n",(0,c.jsxs)(n.p,{children:["Agents support a ",(0,c.jsx)(n.code,{children:"defineCycle()"})," method, triggered periodically to verify or reconcile the external-world state."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export class MyAgent extends Agent {\n    IArgument: {\n        accountId: string;\n    };\n\n    identity() {\n        return this.argument.accountId;\n    }\n\n    version = '1.0.0';\n\n    async defineInstall() {\n        const myAccount = new Account();\n        await this.do('bootstrap', myAccount);\n    }\n\n    async defineUpdate() {\n        const service = new Service().setArgument({\n            accountId: this.argument.accountId,\n        });\n        await this.do('launchService', () => {\n            return service.create();\n        });\n    }\n\n    async defineUninstall() {\n        const service = new Service().setArgument({\n            accountId: this.argument.accountId,\n        });\n        await this.do('launchService', () => {\n            return service.delete();\n        });\n    }\n\n    defaultAgentSettings = {\n        cycle: {\n            frequency: 10 * 60 * 1000, // the cycle hook will run every ten minutes\n        },\n    };\n\n    async defineCycle() {\n        // by default do nothing\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"cycle"})," hook is called:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["at the frequency stored in the ",(0,c.jsx)(n.code,{children:"agentDbDoc"}),", under the path ",(0,c.jsx)(n.code,{children:"cycle.frequency"}),". You can set a first value for this frequency using ",(0,c.jsx)(n.code,{children:"defaultAgentSettings.cycle.frequency"}),"."]}),"\n",(0,c.jsxs)(n.li,{children:["if you force the execution of the ",(0,c.jsx)(n.code,{children:"cycle"})," step using ",(0,c.jsx)(n.code,{children:"setCommand('cycle')"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["By default, the ",(0,c.jsx)(n.code,{children:"cycle"})," hook does nothing. A simple strategy can be, to ensure your agents are up-to-date, to launch a complete digestion hook."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export class MyAgent extends Agent {\n    IArgument: {\n        accountId: string;\n    };\n\n    identity() {\n        return this.argument.accountId;\n    }\n\n    version = '1.0.0';\n\n    async defineInstall() {\n        const myAccount = new Account();\n        await this.do('bootstrap', myAccount);\n    }\n\n    async defineUpdate() {\n        const service = new Service().setArgument({\n            accountId: this.argument.accountId,\n        });\n        await this.do('launchService', () => {\n            return service.create();\n        });\n    }\n\n    async defineUninstall() {\n        const service = new Service().setArgument({\n            accountId: this.argument.accountId,\n        });\n        await this.do('launchService', () => {\n            return service.delete();\n        });\n    }\n\n    defaultAgentSettings = {\n        cycle: {\n            frequency: 10 * 60 * 1000, // the cycle hook will run every ten minutes\n        },\n    };\n\n    async defineCycle() {\n        await this.do('digest', this.agent); // launch a digest cycle\n    }\n}\n"})}),"\n",(0,c.jsx)(n.h4,{id:"using-agents-in-a-workflow",children:"Using agents in a workflow"}),"\n",(0,c.jsx)(n.p,{children:"You can execute a Agent like any other Workflow. Its default command is derived from current state (e.g. install or update):"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export class MyWorkflow extends Workflow {\n    define() {\n        await this.do(\n            'myAgent',\n            new MyAgent().setArgument({ accountId })\n        );\n    }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"Or force a specific command:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export class MyWorkflow extends Workflow {\n    define() {\n        this.do(\n            'agentUpToDate',\n            new MyAgent().setArgument({\n                accountId: this.argument.accountId,\n            })\n        ).setCommand('update');\n    }\n}\n"})}),"\n",(0,c.jsx)(n.h4,{id:"custom-hooks",children:"Custom Hooks"}),"\n",(0,c.jsxs)(n.p,{children:["In addition to the standard lifecycle hooks (install, update, uninstall, cycle), a ",(0,c.jsx)(n.code,{children:"Agent"})," can expose custom hooks. These are useful when you want to support additional behaviors that do not fit into the predefined lifecycle."]}),"\n",(0,c.jsxs)(n.p,{children:["To define a custom hook, you simply create a ",(0,c.jsx)(n.code,{children:"defineX()"})," method, where ",(0,c.jsx)(n.code,{children:"X"})," is the name of your custom command (starting with an uppercase letter):"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"export class MyAgent extends Agent {\n    IArgument: {\n        accountId: string;\n    };\n\n    identity() {\n        return this.argument.accountId;\n    }\n\n    async defineSyncPermissions() {\n        await this.do(\n            'syncIAM',\n            new SyncIAMWorkflow().setArgument({\n                accountId: this.argument.accountId,\n            })\n        );\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["To invoke this hook, use ",(0,c.jsx)(n.code,{children:'.setCommand("syncPermissions")'})," from any workflow:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"await this.do(\n    'res',\n    new MyAgent().setArgument({ accountId }).setCommand('syncPermissions')\n);\n"})}),"\n",(0,c.jsx)(n.p,{children:"Custom hooks allow agents to be extended with additional behaviors while still benefiting from identity-based deduplication and persistent state management."}),"\n",(0,c.jsx)(n.admonition,{type:"info",children:(0,c.jsxs)(n.p,{children:["Custom hook names must match the format ",(0,c.jsx)(n.code,{children:"defineMyCommand"}),', and are called by passing "myCommand" to ',(0,c.jsx)(n.code,{children:"setCommand()"})," (case-sensitive)."]})}),"\n",(0,c.jsx)(n.h3,{id:"convergent-execution-coalescing",children:"Convergent Execution (Coalescing)"}),"\n",(0,c.jsxs)(n.p,{children:["When multiple identical agent instances (same constructor and identity) are triggered concurrently ",(0,c.jsx)(n.strong,{children:"with the same command"}),", the system ensures that only one execution runs. The other invocations will wait and reuse the result of the running instance."]}),"\n",(0,c.jsx)(n.p,{children:"This is known as coalescing, and it ensures consistency, reduces overhead, and prevents race conditions."}),"\n",(0,c.jsx)(n.p,{children:"Example:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"// ...some context\nawait this.do('my-agent', new Agent().setCommand('update'));\n// ...some other context elsewhere, called in the same time\nawait this.do('my-agent', new Agent().setCommand('update'));\n"})}),"\n",(0,c.jsxs)(n.p,{children:["The two workflows want to run the ",(0,c.jsx)(n.code,{children:"update"})," agent command.\nOnly one ",(0,c.jsx)(n.code,{children:"update"})," agent command will be launched and the two workflows steps will have the same result."]}),"\n",(0,c.jsx)(n.h3,{id:"divergent-execution-lock",children:"Divergent Execution (lock)"}),"\n",(0,c.jsxs)(n.p,{children:["When multiple identical agent instances are triggered concurrently with ",(0,c.jsx)(n.em,{children:"different commands"}),", only one will execute. The others will fail with a lock error to prevent command conflicts."]}),"\n",(0,c.jsx)(n.p,{children:"Example :"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"// ...some context\nawait this.do('my-agent', new Agent().setCommand('update'));\n// ...some other context elsewhere, called in the same time\nawait this.do('my-agent', new Agent().setCommand('install')); // will be in error, as command 'update' is being executed.\n"})}),"\n",(0,c.jsxs)(n.p,{children:["The first workflow wants to run the ",(0,c.jsx)(n.code,{children:"update"})," agent command.\nThe second workflow wants to run the ",(0,c.jsx)(n.code,{children:"install"})," agent command.\nIn this case, the update command will proceed, and the install command will be rejected due to command incompatibility."]}),"\n",(0,c.jsxs)(n.p,{children:["The set of mutually exclusive commands is defined in the ",(0,c.jsx)(n.code,{children:"noConcurrencyCommandNames"})," property of the Agent class. When adding custom hooks, you should include them in this list if they require exclusivity."]}),"\n",(0,c.jsxs)(n.admonition,{type:"info",children:[(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.em,{children:"Best practices:"})," Avoid manually specifying commands unless necessary. Let the agent determine the correct hook automatically."]}),(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"// ...some context\nawait this.do('my-agent', new Agent());\n// ...safely coalesce\nawait this.do('my-agent', new Agent());\n"})})]}),"\n",(0,c.jsx)(n.h3,{id:"digest-method",children:"Digest method"}),"\n",(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"digest()"})," method determines which commands (hooks) should be executed based on the current state of the agent. It is called during each lifecycle cycle and can be customized when implementing advanced behavior."]}),"\n",(0,c.jsx)(n.p,{children:"Default implementation:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'async digest(): Promise<ScopeOfChanges<string>[]> {\n    const changes = [];\n    if (this.agentDbDoc.version !== this.version) {\n        changes.push(new ScopeOfChanges("install"));\n    }\n    if (this.agentDbDoc.version) {\n        // meaning an install already occurred\n        changes.push(new ScopeOfChanges("update"));\n    }\n    return changes;\n  }\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const c={},i=s.createContext(c);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);