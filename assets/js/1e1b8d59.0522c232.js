"use strict";(self.webpackChunkorbits_doc=self.webpackChunkorbits_doc||[]).push([[9110],{6339:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var s=t(6767),i=t(4848),a=t(8453);const r={slug:"orchestrate-stack",title:"Orchestrating a stack of services across multiple environments",authors:["loic"],tags:["orchestration","node.js","workflow","orbits"]},o=void 0,c={authorsImageUrls:[void 0]},l=[{value:"From workflows to resources",id:"from-workflows-to-resources",level:2},{value:"Defining a BaseResource",id:"defining-a-baseresource",level:3},{value:"Giving an identity to our services",id:"giving-an-identity-to-our-services",level:4},{value:"Sharing a common installation step",id:"sharing-a-common-installation-step",level:4},{value:"Differentiating frontend and backend",id:"differentiating-frontend-and-backend",level:3},{value:"Backend resource",id:"backend-resource",level:4},{value:"Frontend resource",id:"frontend-resource",level:4},{value:"Scaling to multiple tenants",id:"scaling-to-multiple-tenants",level:3},{value:"Managing a stack",id:"managing-a-stack",level:4},{value:"Managing multiple tenants",id:"managing-multiple-tenants",level:4},{value:"What Orbits takes care of under the hood",id:"what-orbits-takes-care-of-under-the-hood",level:2},{value:"Possible enhancements",id:"possible-enhancements",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["In our ",(0,i.jsx)(n.a,{href:"/blog/orchestration-typescript",children:"previous blog post"}),", we introduced the basics of orchestration and showed how to write a deployment workflow for a backend service.\nNow, let\u2019s take it further.\nImagine our web agencies manage web services across multiple tenants : one cloud instance per client. The stack includes several services, such as frontend, authentication, and backend. And it must support multi-tenant deployment.\nThis brings new challenges:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"coordinating deployments across environments"}),"\n",(0,i.jsx)(n.li,{children:"sharing common resources (like a cloud account, a VPC, a database...) between services in the stack"}),"\n",(0,i.jsx)(n.li,{children:"handling failures and rollbacks"}),"\n",(0,i.jsx)(n.li,{children:"keeping each tenant isolated yet manageable\nTo address this, we need to go beyond simple workflows and start managing state, transitions, shared resources, and deployment strategies.\nLet\u2019s see how simple this becomes with Orbits."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"orchestration",src:t(9738).A+"",width:"1528",height:"611"})}),"\n",(0,i.jsx)(n.h2,{id:"from-workflows-to-resources",children:"From workflows to resources"}),"\n",(0,i.jsxs)(n.p,{children:["In Orbits, a ",(0,i.jsx)(n.code,{children:"Workflow"})," is a one-time execution: it runs, performs its actions, and then it's done. While this is useful, it's not enough when you want to manage stateful, reusable services across multiple environments or tenants."]}),"\n",(0,i.jsxs)(n.p,{children:["Instead, Orbits introduces the concept of a ",(0,i.jsx)(n.code,{children:"Resource"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"Resource"})," encapsulates both the identity of what you\u2019re deploying and the logic for how to install, update, or manage it. Resources can be reused, composed, and tracked."]}),"\n",(0,i.jsx)(n.h3,{id:"defining-a-baseresource",children:"Defining a BaseResource"}),"\n",(0,i.jsx)(n.h4,{id:"giving-an-identity-to-our-services",children:"Giving an identity to our services"}),"\n",(0,i.jsxs)(n.p,{children:["To manage multiple services per tenant, such as frontend and backend, we start by defining a ",(0,i.jsx)(n.code,{children:"BaseResource"}),". This base class provides a common identity mechanism using the tenantId and a service-specific name. The ",(0,i.jsx)(n.code,{children:"identity()"})," method uniquely identifies each resource instance, which allows Orbits to track, reconcile, and avoid duplicating shared resources."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class BaseResource extends Resource {\n    IArgument: {\n        tenantId: string;\n    };\n\n    serviceName = 'base';\n\n    identity() {\n        return `${this.serviceName}-${this.argument.tenantId}`;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"sharing-a-common-installation-step",children:"Sharing a common installation step"}),"\n",(0,i.jsx)(n.p,{children:"Orbits ressources distinguish between the installation phase and the update phase. This allows precise control over what happens during first-time deployment versus subsequent updates."}),"\n",(0,i.jsxs)(n.p,{children:["We can implement shared setup, such as Git repository creation and cloud account provisioning, in the ",(0,i.jsx)(n.code,{children:"defineInstall()"})," method of ",(0,i.jsx)(n.code,{children:"BaseResource"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class BaseResource extends Resource {\n    async defineInstall() {\n        const createGit = new GitResource().setArgument({\n            name: this.serviceName,\n        });\n        const createAWS = new AWSResource().setArgument({\n            id: this.tenantId,\n        });\n\n        await Promise.all([\n            this.do('git-install', createGit),\n            this.do('aws-install', createAWS),\n        ]);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this setup:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["GitResource uses ",(0,i.jsx)(n.code,{children:"serviceName"}),", so each service (frontend, backend) gets its own Git repository."]}),"\n",(0,i.jsxs)(n.li,{children:["AWSResource uses ",(0,i.jsx)(n.code,{children:"tenantId"}),", ensuring every services share the same cloud account for a given tenant : no duplicate account will be created."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"differentiating-frontend-and-backend",children:"Differentiating frontend and backend"}),"\n",(0,i.jsxs)(n.p,{children:["Once the shared installation is abstracted, each service can implement its own logic tailored to its infrastructure and operational needs.\nHere we modify the ",(0,i.jsx)(n.code,{children:"update"})," step."]}),"\n",(0,i.jsx)(n.h4,{id:"backend-resource",children:"Backend resource"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class BackendResource extends BaseResource {\n    declare serviceName = 'backend';\n\n    async defineUpdate() {\n        // Step 1: Deploy Infrastructure-as-Code\n        const deploymentOutput = await this.do(\n            'iac-deploy',\n            new BackCDKStack()\n        );\n\n        // Step 2: Run SQL migrations inside the provisioned environment\n        const migration = new RunSQLMigrations();\n        migration.executor = new CloudExecutor(deploymentOutput.env);\n        await this.do('sql-migrate', migration);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"frontend-resource",children:"Frontend resource"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class FrontendResource extends BaseResource {\n    declare serviceName = 'frontend';\n\n    async defineUpdate() {\n        // Step 1: Deploy Infrastructure-as-Code\n        const deploymentOutput = await this.do(\n            'iac-deploy',\n            new FrontCDKStack()\n        );\n\n        // Step 2: clear caches inside the provisioned environment\n        await this.do(\n            'clear-cdn-cache',\n            new CdnClearCacheAction().setArgument({\n                cdnArn: deploymentOutput.cdnArn,\n            })\n        );\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This pattern offers:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"clear separation of concerns between services"}),"\n",(0,i.jsx)(n.li,{children:"reusability of common setup logic"}),"\n",(0,i.jsx)(n.li,{children:"flexibility for specialized behavior per service"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"scaling-to-multiple-tenants",children:"Scaling to multiple tenants"}),"\n",(0,i.jsx)(n.h4,{id:"managing-a-stack",children:"Managing a stack"}),"\n",(0,i.jsx)(n.p,{children:"Now let\u2019s define an application stack that orchestrates both frontend and backend services. This approach gives us control over the deployment order, error handling, and rollback strategy.\nBelow is a schematic version of what this orchestration might look like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class MyStack extends Resource {\n    async defineUpdate() {\n        //choose a deployment strategy\n        //here we first deploy the frontend and then the backend.\n        //could have done this in parellel\n        const backendResource = new BackendResource().setArgument(\n            this.argument\n        );\n        const frontendResource = new FrontendResource().setArgument(\n            this.argument\n        );\n        try {\n            await this.do('update-backend', backendResource);\n            await this.do('update-frontend', frontendResource);\n        } catch (err) {\n            //rollback to previous working commit\n            await this.do(\n                'rollback-frontend',\n                frontendResource.setCommand('rollback')\n            );\n            await this.do(\n                'rollback-backend',\n                backendResource.setCommand('rollback')\n            );\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"You could easily parallelize both deployments using Promise.all if the order doesn\u2019t matter."})}),"\n",(0,i.jsx)(n.h4,{id:"managing-multiple-tenants",children:"Managing multiple tenants"}),"\n",(0,i.jsx)(n.p,{children:"To scale across tenants, we define a Tenants resource that loops over each tenant and applies the stack. Failures are isolated and can be reported via Slack, email, or any other channel."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class Tenants extends Resource {\n    // you would likely fetch this from a database\n    tenants = ['clientA', 'clientB', 'clientC'];\n\n    async defineUpdate() {\n        const failed = [];\n\n        for (const tenantId of this.argument.tenants) {\n            try {\n                await this.do(\n                    'update-tenant',\n                    new MyStack().setArgument({ tenantId })\n                );\n            } catch (err) {\n                failed.push({ tenantId, error: err });\n                // Optionally notify immediately, or collect all and notify later\n            }\n        }\n\n        if (failed.length > 0) {\n            await this.do(\n                'notify-failures',\n                new SlackNotification().setArgument({ failures: failed })\n            );\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"what-orbits-takes-care-of-under-the-hood",children:"What Orbits takes care of under the hood"}),"\n",(0,i.jsx)(n.p,{children:"This simple syntax addresses common pain points in managing cloud services under the hood:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"avoiding duplication: when multiple executions of a resource run in parallel, Orbits ensures the same final state without recreating resources unnecessarily. The orchestrator intelligently determines what needs updating, skipping, or preserving."}),"\n",(0,i.jsx)(n.li,{children:"running scripts in different contexts : The concept of an executor provides a clean way to run specific actions within the right environment or context. Since infrastructure and scripts are managed together, it\u2019s easy to target the exact environment where a command should execute."}),"\n",(0,i.jsxs)(n.li,{children:["safe error handling: Encapsulating orchestration logic in ",(0,i.jsx)(n.code,{children:"Resource"})," enables rollback strategies when something fails mid-deployment."]}),"\n",(0,i.jsxs)(n.li,{children:["multi-Tenant scalability: The ",(0,i.jsx)(n.code,{children:"Tenants"})," resource allows applying the same stack logic across many clients, while isolating failures and surfacing them clearly."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"possible-enhancements",children:"Possible enhancements"}),"\n",(0,i.jsx)(n.p,{children:"This example provides a basic overview of how we manage multi-tenant deployments. Looking ahead, there are several potential improvements that can be explored:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"we could implement more complex rollback strategies"}),"\n",(0,i.jsxs)(n.li,{children:["we could implement drift detection via the ",(0,i.jsx)(n.code,{children:"cycle"})," hook"]}),"\n",(0,i.jsxs)(n.li,{children:["we could share some resources accross tenants with the same concept of ",(0,i.jsx)(n.code,{children:"Resource"})]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Wanna try Orbits? The complete documentation with samples and examples is available ",(0,i.jsx)(n.a,{href:"https://orbits.do/documentation",children:"here"}),". The source code is available in the ",(0,i.jsx)(n.a,{href:"https://github.com/LaWebcapsule/orbits",children:"github repository"}),". Give it a spin!"]})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},6767:e=>{e.exports=JSON.parse('{"permalink":"/blog/orchestrate-stack","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-09-26-orchestrate-a-stack-of-services.md","source":"@site/blog/2025-09-26-orchestrate-a-stack-of-services.md","title":"Orchestrating a stack of services across multiple environments","description":"In our previous blog post, we introduced the basics of orchestration and showed how to write a deployment workflow for a backend service.","date":"2025-09-26T00:00:00.000Z","tags":[{"inline":true,"label":"orchestration","permalink":"/blog/tags/orchestration"},{"inline":true,"label":"node.js","permalink":"/blog/tags/node-js"},{"inline":true,"label":"workflow","permalink":"/blog/tags/workflow"},{"inline":false,"label":"OrbiTS","permalink":"/blog/tags/orbits","description":"Posts related to OrbiTS"}],"readingTime":5.01,"hasTruncateMarker":true,"authors":[{"name":"Lo\xefc D\xe9champs","title":"CTO @ Webcapsule","url":"https://github.com/ldechamps","page":{"permalink":"/blog/authors/loic"},"socials":{"linkedin":"https://www.linkedin.com/in/loicdechamps/","github":"https://github.com/ldechamps"},"imageURL":"/img/authors/loic.png","key":"loic"}],"frontMatter":{"slug":"orchestrate-stack","title":"Orchestrating a stack of services across multiple environments","authors":["loic"],"tags":["orchestration","node.js","workflow","orbits"]},"unlisted":false,"nextItem":{"title":"Write your CI/CD in TypeScript","permalink":"/blog/ci-cd-in-typescript"}}')},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}},9738:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/orchestration-2-05e7a9be561bc7bac6cf22d543f4c4aa.png"}}]);